________________________________________________________________________

# СОДЕРЖАНИЕ #

- > **[КРАТКАЯ ТЕОРИЯ](#краткая-теория)**
- > **[ПРИНЦИПЫ](#принципы)**
    1. > **[ОСНОВНЫЕ ПРИНЦИПЫ ООП](#основные-принципы-ооп)**
    1. > **[KISS, DRY, YAGNI И ДР.](#kiss-dry-yagni-и-др)**
    1. > **[SOLID](#solid)**
- > **[ПАТТЕРНЫ](#паттерны)**
- > **[ИСТОЧНИКИ И ДОП. МАТЕРИАЛЫ](#источники-и-доп-материалы)**
________________________________________________________________________

# КРАТКАЯ ТЕОРИЯ #

*Объектно-ориентированное программирование* (ООП) - это парадигма
разработки и подход к организации программ, основанный на концепции
объектов.

*Объект* (экземпляр класса) - сущность, обладающая состоянием и
поведением. Состояние описывается через *атрибуты* - хар-ки объекта.
Поведение описывается через *методы* - ф-ции внутри объекта, которые
позволяют ему взаимодействовать с собой, своими атрибутами и методами
или другой частью кода (будь то переменные, функции или другие объекты).

*Класс* - шаблон для создания объектов.

Код в ООП должен соответствовать основным принципам ООП, описанным в
разделе Принципы.
________________________________________________________________________

Преимущества ООП по сравнению с ФП:

- В парадигме объектов легче писать код. Удобно один раз создать класс
    или метод, а потом его использовать, без переписывания большого
    кол-ва строк кода.
- Код понятнее, а читать его гораздо проще. В парадигме ООП программа
    становится чуточку ближе к реальному миру с его различными
    объектами, состояниями и поведением, отчего код проще
    интерпретировать. Кроме того, код становится структурированнее.
- Код легче обновлять и поддерживать. Класс или метод достаточно
    изменить в одном месте, чтобы он изменился во всех наследуемых
    классах и объектах. Не нужно переписывать каждый объект отдельно.
- Код удобнее переиспользовать.
- Шаблоны проектирования (паттерны) и принципы - готовые решения и
    правила для хорошего кода.

Недостатки ООП по сравнению с ФП:

- Сложность в освоении больше, чем у функционального программирования.
- Громоздкость. Там, где в функциональном программировании хватит одной
    функции для небольшой программы, в ООП нужно создать класс, объект,
    методы и атрибуты. Но для больших программ это оборачивается плюсом
    в виде структурированности.
- Низкая производительность. Объекты потребляют больше памяти, чем
    простые функции и переменные.

Итого: ООП больше подходит для больших программ со сложной структурой, в
то время как для небольших программ предпочтительнее использовать ФП.
________________________________________________________________________

# ПРИНЦИПЫ #

В данном разделе описаны различные принципы в ООП. Некоторые из них
можно (и нужно) отнести ко всем популярным парадигмам программирования,
но в условиях ООП с его громоздкостью и опорой на объекты эти принципы
раскрываются заметно ярче, чем в ФП. Поэтому важно напомнить о них тут.
________________________________________________________________________

### ОСНОВНЫЕ ПРИНЦИПЫ ООП ###

Основные принципы ООП представляют собой важные черты данной парадигмы,
описывая самые базовые механизмы для правильности, эффективности и
удобства использования ООП.
________________________________________________________________________

0. *Абстракция* - возможность моделировать сущности и концепции, выделяя
    главное и опуская детали. С этой стороны абстракция - одна из основ
    ООП, чуть ли не самая базовая идея о классах, но в то же время
    говорящая нам не перегружать код тем, что не нужно (будто повторяя
    идеи другого известного принципа в программировании - YAGNI).

    Например: допустим, мы разрабатываем простенькую RPG-игру, где игрок
    может пользоваться каким-то оружием. Пускай мы хотим добавить в игру
    меч. От реального меча нам много чего может быть нужно, конечно, но
    помня, что игра простенькая, навряд ли нам понадобится точный состав
    меча вплоть до процентов того или иного металла в сплаве. Нам навряд
    ли понадобятся и все возможные стили фехтования, и возможность им
    пользоваться не по назначению - подпирать стол или жонглировать. Для
    простенькой игры лучше иметь всего несколько анимаций, знать урон
    меча, по необх-ти - вес, да и все. За этим - выбор нужного,
    отсечение лишнего - и кроется абстракция.

    С этой стороны мы раскрыли абстракцию - как основу ООП и как
    некоторую родственную принципу YAGNI сущность. Но это еще не все, и
    мы вернемся к ней позже.
________________________________________________________________________

1. *Инкапсуляция* - данные, необходимые для работы объекта, должны
    находиться внутри объекта, а доступ к ним должен быть контролируем.

    Например: пусть в нашей игре есть меч. Хранить вес и урон каждого
    меча лучше в самом экземпляре класса "Меч", чем в каком-нибудь
    списке весов и уронов мече за пределами экземпляров. Кроме того,
    нельзя давать пользователю своевольно менять данные характеристики,
    но смотреть в любой момент - нужно.

    Код:

    ```python
    class Sword:
        """Класс меча."""

        def __init__(self, weight, damage):
            self._weight = weight
            self._damage = damage
        
        @property
        def weight(self):
            """Геттер веса меча."""
            return self._weight
        
        # но не добавяем сеттер для веса, т.к. не хотим, чтобы его
        # кто-то или что-то меняло

        @property
        def damage(self):
            """Геттер урона меча."""
            return self._damage
        
        # с сеттером для урона - аналогично сеттеру веса
    ```

    При этом при механиках облегчения мечей или увеличения урона при
    апгрейде уже нужно что-то придумывать и с сеттерами и описывать
    ограничения, когда можно изменить эти хар-ки, а когда - нельзя. Это
    все так же относится к контролю доступа к данным, который
    подразумевается в инкапсуляции.
________________________________________________________________________

2. *Наследование* - механизм, аналогичный реальному биологическому
    наследованию: есть родительский класс, и на его основе можно сделать
    дочерний класс. Каждый дочерний эл-т наследует методы и атрибуты,
    прописанные в родительском. Он может использовать их все, отбросить
    часть или добавить новые. При этом заново прописывать атрибуты и
    методы родительского класса в дочернем не нужно. Методы и атрибуты -
    своего рода аналогия геному в биологическом наследовании, а
    изменения и новшества в дочернем классе - аналогия мутациям или
    совершенствованиям.

    В то же время наследование как принцип косвенно говорит о том, что
    не стоит повторяться в подходящих под ситуацию "родитель-ребенок"
    случаях и описывать два таких класса отдельно - стоит использовать
    механику наследования.

    Например: пусть в нашей игре есть два меча. Один - обычный меч с
    обычным ударом. Второй - абсолютно такой же, но зачарованный, с
    возможностью использовать специальный удар, наносящий половину
    обычного урона, но накладывающий статус "горение". При этом все
    остальное идентично: есть обычный удар, те же анимации (кроме как
    при спец. приеме), те же атрибуты. В таком ключе лучше создать
    обычный меч как родительский класс, а зачарованный - как дочерний
    класс.

    Код:

    ```python
    # пусть за данной вырезкой находятся класс, описывающий
    # потенциального противника, у которого есть методы take_damage
    # (обрабатывает механику получения урона - кстати, также пример
    # инкапсуляции) и set_status (установить статус), а также классовые
    # константы, описывающие статусы наподобие горения

    class Sword:
        """Класс меча."""

        def __init__(self, weight, damage):
            self._weight = weight
            self._damage = damage
        
        def normal_strike(self, enemy):
            """Обычный удар."""
            enemy.take_damage(self._damage)
        
        # опустим описанные ранее геттеры для атрибутов
        ...
    

    class EnchantedSword(Sword):  # наследуется от Sword

        def fiery_strike(self, enemy):
            """Поджигающий удар."""
            enemy.take_damage(self._damage // 2)
            enemy.set_status(enemy.STATUS_BURN)
    ```

    После такого обьявления класс EnchantedSword инициализируется теми
    же атрибутами, что и Sword, а также имеет те же методы, но, кроме
    того, имеет дополнительный метод, отвечающий за "поджигающий" удар.
    Это и есть наследование.
________________________________________________________________________

3. *Полиморфизм* - принцип взаимозаменяемости схожих классов, говорящий,
    что схожим классам следует предоставлять одинаковый интерфейс для
    выполнения одинаковых по смыслу, но разных по исполнению действий.

    Например: в нашей игре есть не только меч, но и пистолет. Оба имеют
    обычную атаку, но меч просто производит атаку с уроном, а пистолет
    еще и тратит патрон из магазина. Тогда лучшим решением будет
    одинаково назвать методы для этой самой атаки, пускай реализация и
    разнится. В результате вне зависимости от того, какое оружие
    экипировано у игрока, можно будет обратиться к нему по одному и тому
    же методу и произвести нужную нам обычную атаку.

    Код:

    ```python
    class Sword:
        """Класс меча."""

        def __init__(self, weight, damage):
            self._weight = weight
            self._damage = damage
        
        def normal_strike(self, enemy):
            """Обычная атака."""
            enemy.take_damage(self._damage)
        
        ...
    

    class Pistol:
        """Класс пистолета."""

        self._MAX_ROUNDS = 10

        def __init__(self, weight, damage):
            self._weight = weight
            self._damage = damage
            self._rounds = self._MAX_ROUNDS
        
        def normal_strike(self, enemy):  # тот же, что и у Sword
            """Обычная атака."""
            if self._rounds:
                enemy.take_damage(self._damage)
                self._rounds -= 1
            else:
                print('Упс! Нет патронов в магазине!')
        
        def reload(self, rounds):
            """Перезарядка."""
            self._rounds = rounds
        
        ...
    ```

    Как видно из примера, теперь в методе игрока, отвечающего за атаку,
    можно просто вызвать метод normal_strike вне зависимости от того,
    что экипировано, хотя реализации этих методов и в целом классы
    оружия разные и имеют свои особенности.
________________________________________________________________________

4. И снова вернемся к абстракции. На самом деле, помимо описанного ранее
    смысла, абстракция также имеет и проистекающее из наследования и
    полиморфизма иное применение, а именно как объединяющая единица.
    Если есть классы, имеющие схожий смысл и схожие методы, но, кроме
    того, имеющие и различия, то можно для них создать абстрактный
    класс, объединяющий схожие вещи. Т.о. схожие вещи не придется
    описывать несколько раз, как и в наследовании, и для них можно будет
    задать общий интерфейс, как и в полиморфизме. Это и есть основной
    смысл и назначение абстракции как принципа ООП.

    Например: пусть в нашей игре есть меч, топор, молот, лук, пистолет и
    автомат. Тогда хорошим решением будет создать абстрактный класс
    "Оружие", где можно прописать получение значений атрибутов веса,
    урона, а также абстрактный метод как общий интерфейс для обычной
    атаки. Затем создать еще 2 унаследованных от "Оружия" класса
    "Ближнебойного оружия" и "Дальнобойного оружия", описывающее их
    особенности. А затем от этих двух наследовать классы конкретных
    оружий.

    Код:

    ```python
    from abc import abstractmethod

    class Weapon:
        """Абстрактный класс оружия."""

        def __init__(self, weight, damage):
            self._weight = weight
            self._damage = damage
        
        @abstractmethod
        def normal_strike(self, enemy):
            """Обычная атака."""
            pass

        # здесь и далее позволю себе не вдаваться в подробности кода и
        # отмечу такие места троеточием
        ...
        
    
    class MeleeWeapon(Weapon):  # наследуется от абстрактного Weapon
        """Абстрактный класс ближнебойного оружия."""

        def normal_strike(self, enemy):
            """Обычная атака."""
            ...
    

    class RangeWeapon(Weapon):  # наследуется от абстрактного Weapon
        """Абстрактный класс дальнобойного оружия."""

        self._MAX_ROUNDS: int

        def __init__(self, weight, damage):
            super().__init__(weight, damage)
            self._rounds = self._MAX_ROUNDS

        def normal_strike(self, enemy):
            """Обычная атака."""
            ...

        def reload(self, rounds):
            """Перезарядка."""
            ...
    

    class Sword(MeleeWeapon):  # наследуется от абстрактного MeleeWeapon
        """Класс меча."""
        ...
    

    # и т.д. по ближнебойным оружиям
    ...


    class Bow(RangeWeapon):  # наследуется от абстрактного RangeWeapon
        """Класс лука."""
        ...
    
    
    # и т.д. по дальнобойным оружиям
    ...
    ```

    И позволю себе доп. заметку. Абстракцию часто не упоминают как
    принцип, т.к. он является скорее следствием от наследования и
    полиморфизма, чем самостоятельным принципом. Тем не менее, на самом
    деле все принципы связаны между собой и по отдельности в контексте
    ООП имеют мало смысла. Абстракция - такой же полноправный принцип,
    как и прочие, и не стоит его пропускать.
________________________________________________________________________

### KISS, DRY, YAGNI И ДР. ###

Данные принципы являются общеупотребимыми в программировании, а не
только в контексте ООП. Основные из них вынесены в названии - KISS, DRY
и YAGNI. Кроме того, еще одним основным принципом является SOLID, но
он представляет собой более комплексную единицу и по этой причине
вынесен в отдельную подтему. Обычно эти 4 принципа и описываются или
указываюся. Но кроме них есть еще несколько полезных полезных принципов,
предложенных в данной подтеме конспекта.

Основное назначение всех этих принципов - эффективная, удобная и
понятная разработка программ.
________________________________________________________________________

1. **KISS** - Keep It Simple, Stupid - "будь проще". Данный принцип
    призывает не переусложнять код: не стоит придумывать решение
    сложнее, чем необходимо. Содержит в себе также следующие
    утверждения:
    - Простые системы надежнее всего работают.
    - Не стоит переизобретать колесо.

2. **DRY** - Don't Repeat Yourself - "не повторяйся". Не стоит
    дублировать код, иначе его сложнее поддерживать, а изменение в одном
    экземпляре приведет к потребности искать и изменять в остальных.
    Кратко говоря, бездумный копипаст - это плохая практика. Лучше
    вместо этого поискать решение среди имеющихся инструментов или
    написать ф-цию, класс и т.д.

3. **YAGNI** - You Aren't Gonna Need It - "тебе это не понадобится". Не
    писать и не оставлять то, что понадобится в будущем или было нужно
    раньше, но сейчас не используется. Писать и оставлять только то, что
    нужно сейчас. Захламленный неиспользуемыми блоками код усложняет его
    поддержку.

4. **BDUF** - Dig Design Up Front - "глобальное проектирование прежде
    всего". Прежде чем переходить к реализации, стоит все хорошо
    продумать. Составить план, схему проекта, продумать архитектуру,
    провести аналитику и проч. - и только тогда приступать к разработке.

5. **APO** - Avoid Premature Optimization - "избегай преждевременной
    оптимизации". Сильно связан с KISS и YAGNI, т.к. нарушение APO чаще
    всего нарушает и их. Призывает оптимизировать только по необх-ти и
    действительной полезности, а не преждевременно. Кроме того,
    напоминает, что важнее сделать поддерживаемый и рабочий код в
    заданные сроки, чем максимально оптимизированный.

6. **Бритва Оккама** - "не следует множить сущее без необходимости".
    Также своего рода наследник KISS и YAGNI, говорящий не создавать
    сущности без необходимости. Это относится как к неиспользуемым
    сущностям на будущее, так и используемым, но без необх-ти на то
    усложняющим код - "сущность ради сущности".
________________________________________________________________________

Данные принципы важны, но стоит учитывать ситуацию и контекст. Каждый из
принципов может быть нарушен в зав-ти от ситуации. Например:

- SOLID, описанный далее, часто в некотором смысле конфликтует с KISS,
    DRY и YAGNI, так что приходится выбирать. Чаще всего в такой
    ситуации лучшее решение будет за SOLID.
- DRY часто нарушается в больших проектах, а обдуманный копипаст с
    последующим улучшением бывает крайне полезен.
- BDUF - не всегда получается все продумать наперед, а дедлайны не дадут
    размышлять над этим вечно.
- YAGNI, APO, Оккама - в реальности хватает ситуаций, когда придется
    идти поперек и делать раньше, чем нужно - а именно сразу,
    непосредственно в течение текущей разработки, а не в последующем в
    ходе улучшений кода, с продумыванием наперед прямо в процессе.

Поэтому не стоит бояться их нарушить, это нормально и крайне часто имеет
место быть, но делать это надо обдуманно. Кроме, пожалуй, SOLID, который
нарушать крайне нежелательно.
________________________________________________________________________

### SOLID ###

...
________________________________________________________________________

# ПАТТЕРНЫ #

...
________________________________________________________________________

# ИСТОЧНИКИ И ДОП. МАТЕРИАЛЫ #

1. [Сайт] **Статья по ООП от Яндекс Практикума**:
    [ссылка](https://practicum.yandex.ru/blog/obektno-orientirovannoe-programmirovanie/).
1. [Сайт] **Статья по KISS, DRY, YAGNI, SOLID и т.д. на Хабре**:
    [ссылка](https://habr.com/ru/companies/itelma/articles/546372/).
1. [Сайт] **Статья о SOLID на Хабре**:
    [ссылка](https://habr.com/ru/companies/ruvds/articles/426413/).
1. [Литература] **Э. Гамма, Р. Хелм, Р. Джонсон, Дж. Влиссидес ("Банда**
    **Четырех") - Паттерны ООП**.
1. [Сайт] **Шпаргалки по паттернам проектирования**:
    [ссылка](http://refactoringu.ru/ru/design-patterns/catalog.html),
    [ссылка](https://bool.dev/blog/detail/gof-design-patterns).
________________________________________________________________________
