________________________________________________________________________

# СОДЕРЖАНИЕ #

- > **[КРАТКАЯ ТЕОРИЯ](#краткая-теория)**
- > **[ПРИНЦИПЫ](#принципы)**
    1. > **[ОСНОВНЫЕ ПРИНЦИПЫ ООП](#основные-принципы-ооп)**
    1. > **[KISS, DRY, YAGNI И ДР.](#kiss-dry-yagni-и-др)**
    1. > **[SOLID](#solid)**
- > **[ПАТТЕРНЫ](#паттерны)**
    - > **[ПОРОЖДАЮЩИЕ](#порождающие)**
        1. > **[Абстрактная фабрика](#абстрактная-фабрика)**
        1. > **[Строитель](#строитель)**
        1. > **[Фабричный метод](#фабричный-метод)**
        1. > **[Прототип](#прототип)**
        1. > **[Одиночка (Синглтон)](#одиночка-синглтон)**
    - > **[СТРУКТУРНЫЕ](#структурные)**
        1. > **[Адаптер](#адаптер)**
        1. > **[Мост](#мост)**
        1. > **[Компоновщик](#компоновщик)**
        1. > **[Декоратор](#декоратор)**
        1. > **[Фасад](#фасад)**
        1. > **[Приспособленец (Легковес)](#приспособленец-легковес)**
        1. > **[Заместитель](#заместитель)**
    - > **[ПОВЕДЕНЧЕСКИЕ](#поведенческие)**
        1. > **[Цепочка обязанностей](#цепочка-обязанностей)**
        1. > **[Команда](#команда)**
        1. > **[Интерпретатор](#интерпретатор)**
        1. > **[Итератор](#итератор)**
        1. > **[Посредник](#посредник)**
        1. > **[Хранитель](#хранитель)**
        1. > **[Наблюдатель](#наблюдатель)**
        1. > **[Состояние](#состояние)**
        1. > **[Стратегия](#стратегия)**
        1. > **[Шаблонный метод](#шаблонный-метод)**
        1. > **[Посетитель](#посетитель)**
- > **[ИСТОЧНИКИ И ДОП. МАТЕРИАЛЫ](#источники-и-доп-материалы)**
________________________________________________________________________

# КРАТКАЯ ТЕОРИЯ #

*Объектно-ориентированное программирование* (ООП) - это парадигма
разработки и подход к организации программ, основанный на концепции
объектов.

*Объект* (экземпляр класса) - сущность, обладающая состоянием и
поведением. Состояние описывается через *атрибуты* - хар-ки объекта.
Поведение описывается через *методы* - ф-ции внутри объекта, которые
позволяют ему взаимодействовать с собой, своими атрибутами и методами
или другой частью кода (будь то переменные, функции или другие объекты).

*Класс* - шаблон для создания объектов.

Код в ООП должен соответствовать основным принципам ООП, описанным в
разделе Принципы.
________________________________________________________________________

Преимущества ООП по сравнению с ФП:

- В парадигме объектов легче писать код. Удобно один раз создать класс
    или метод, а потом его использовать, без переписывания большого
    кол-ва строк кода.
- Код понятнее, а читать его гораздо проще. В парадигме ООП программа
    становится чуточку ближе к реальному миру с его различными
    объектами, состояниями и поведением, отчего код проще
    интерпретировать. Кроме того, код становится структурированнее.
- Код легче обновлять и поддерживать. Класс или метод достаточно
    изменить в одном месте, чтобы он изменился во всех наследуемых
    классах и объектах. Не нужно переписывать каждый объект отдельно.
- Код удобнее переиспользовать.
- Шаблоны проектирования (паттерны) и принципы - готовые решения и
    правила для хорошего кода.

Недостатки ООП по сравнению с ФП:

- Сложность в освоении больше, чем у функционального программирования.
- Громоздкость. Там, где в функциональном программировании хватит одной
    функции для небольшой программы, в ООП нужно создать класс, объект,
    методы и атрибуты. Но для больших программ это оборачивается плюсом
    в виде структурированности.
- Низкая производительность. Объекты потребляют больше памяти, чем
    простые функции и переменные.

Итого: ООП больше подходит для больших программ со сложной структурой, в
то время как для небольших программ предпочтительнее использовать ФП.
________________________________________________________________________

# ПРИНЦИПЫ #

В данном разделе описаны различные принципы в ООП. Некоторые из них
можно (и нужно) отнести ко всем популярным парадигмам программирования,
но в условиях ООП с его громоздкостью и опорой на объекты эти принципы
раскрываются заметно ярче, чем в ФП. Поэтому важно напомнить о них тут.
________________________________________________________________________

### ОСНОВНЫЕ ПРИНЦИПЫ ООП ###

Основные принципы ООП представляют собой важные черты данной парадигмы,
описывая самые базовые механизмы для правильности, эффективности и
удобства использования ООП.
________________________________________________________________________

0. *Абстракция* - возможность моделировать сущности и концепции, выделяя
    главное и опуская детали. С этой стороны абстракция - одна из основ
    ООП, чуть ли не самая базовая идея о классах, но в то же время
    говорящая нам не перегружать код тем, что не нужно (будто повторяя
    идеи другого известного принципа в программировании - YAGNI).

    Например: допустим, мы разрабатываем простенькую RPG игру, где игрок
    может пользоваться каким-то оружием. Пускай мы хотим добавить в игру
    меч. От реального меча нам много чего может быть нужно, конечно, но
    помня, что игра простенькая, навряд ли нам понадобится точный состав
    меча вплоть до процентов того или иного металла в сплаве. Нам навряд
    ли понадобятся и все возможные стили фехтования, и возможность им
    пользоваться не по назначению - подпирать стол или жонглировать. Для
    простенькой игры лучше иметь всего несколько анимаций, знать урон
    меча, по необх-ти - вес, да и все. За этим - выбор нужного,
    отсечение лишнего - и кроется абстракция.

    С этой стороны мы раскрыли абстракцию - как основу ООП и как
    некоторую родственную принципу YAGNI сущность. Но это еще не все, и
    мы вернемся к ней позже.
________________________________________________________________________

1. *Инкапсуляция* - данные, необходимые для работы объекта, должны
    находиться внутри объекта, а доступ к ним должен быть контролируем.

    Например: пусть в нашей игре есть меч. Хранить вес и урон каждого
    меча лучше в самом экземпляре класса "Меч", чем в каком-нибудь
    списке весов и уронов мече за пределами экземпляров. Кроме того,
    нельзя давать пользователю своевольно менять данные характеристики,
    но смотреть в любой момент - нужно.

    Код:

    ```python
    class Sword:
        """Класс меча."""

        def __init__(self, weight, damage):
            self._weight = weight
            self._damage = damage
        
        @property
        def weight(self):
            """Геттер веса меча."""
            return self._weight
        
        # но не добавяем сеттер для веса, т.к. не хотим, чтобы его
        # кто-то или что-то меняло

        @property
        def damage(self):
            """Геттер урона меча."""
            return self._damage
        
        # с сеттером для урона - аналогично сеттеру веса
    ```

    При этом при механиках облегчения мечей или увеличения урона при
    апгрейде уже нужно что-то придумывать и с сеттерами и описывать
    ограничения, когда можно изменить эти хар-ки, а когда - нельзя. Это
    все так же относится к контролю доступа к данным, который
    подразумевается в инкапсуляции.
________________________________________________________________________

2. *Наследование* - механизм, аналогичный реальному биологическому
    наследованию: есть родительский класс, и на его основе можно сделать
    дочерний класс. Каждый дочерний эл-т наследует методы и атрибуты,
    прописанные в родительском. Он может использовать их все, отбросить
    часть или добавить новые. При этом заново прописывать атрибуты и
    методы родительского класса в дочернем не нужно. Методы и атрибуты -
    своего рода аналогия геному в биологическом наследовании, а
    изменения и новшества в дочернем классе - аналогия мутациям или
    совершенствованиям.

    В то же время наследование как принцип косвенно говорит о том, что
    не стоит повторяться в подходящих под ситуацию "родитель-ребенок"
    случаях и описывать два таких класса отдельно - стоит использовать
    механику наследования.

    Например: пусть в нашей игре есть два меча. Один - обычный меч с
    обычным ударом. Второй - абсолютно такой же, но зачарованный, с
    возможностью использовать специальный удар, наносящий половину
    обычного урона, но накладывающий статус "горение". При этом все
    остальное идентично: есть обычный удар, те же анимации (кроме как
    при спец. приеме), те же атрибуты. В таком ключе лучше создать
    обычный меч как родительский класс, а зачарованный - как дочерний
    класс.

    Код:

    ```python
    # пусть за данной вырезкой находятся класс, описывающий
    # потенциального противника, у которого есть методы take_damage
    # (обрабатывает механику получения урона - кстати, также пример
    # инкапсуляции) и set_status (установить статус), а также классовые
    # константы, описывающие статусы наподобие горения

    class Sword:
        """Класс меча."""

        def __init__(self, weight, damage):
            self._weight = weight
            self._damage = damage
        
        def normal_strike(self, enemy):
            """Обычный удар."""
            enemy.take_damage(self._damage)
        
        # опустим описанные ранее геттеры для атрибутов
        ...
    

    class EnchantedSword(Sword):  # наследуется от Sword

        def fiery_strike(self, enemy):
            """Поджигающий удар."""
            enemy.take_damage(self._damage // 2)
            enemy.set_status(enemy.STATUS_BURN)
    ```

    После такого обьявления класс EnchantedSword инициализируется теми
    же атрибутами, что и Sword, а также имеет те же методы, но, кроме
    того, имеет дополнительный метод, отвечающий за "поджигающий" удар.
    Это и есть наследование.
________________________________________________________________________

3. *Полиморфизм* - принцип взаимозаменяемости схожих классов, говорящий,
    что схожим классам следует предоставлять одинаковый интерфейс для
    выполнения одинаковых по смыслу, но разных по исполнению действий.

    Например: в нашей игре есть не только меч, но и пистолет. Оба имеют
    обычную атаку, но меч просто производит атаку с уроном, а пистолет
    еще и тратит патрон из магазина. Тогда лучшим решением будет
    одинаково назвать методы для этой самой атаки, пускай реализация и
    разнится. В результате вне зависимости от того, какое оружие
    экипировано у игрока, можно будет обратиться к нему по одному и тому
    же методу и произвести нужную нам обычную атаку.

    Код:

    ```python
    class Sword:
        """Класс меча."""

        def __init__(self, weight, damage):
            self._weight = weight
            self._damage = damage
        
        def normal_strike(self, enemy):
            """Обычная атака."""
            enemy.take_damage(self._damage)
        
        ...
    

    class Pistol:
        """Класс пистолета."""

        self._MAX_ROUNDS = 10

        def __init__(self, weight, damage):
            self._weight = weight
            self._damage = damage
            self._rounds = self._MAX_ROUNDS
        
        def normal_strike(self, enemy):  # тот же, что и у Sword
            """Обычная атака."""
            if self._rounds:
                enemy.take_damage(self._damage)
                self._rounds -= 1
            else:
                print('Упс! Нет патронов в магазине!')
        
        def reload(self, rounds):
            """Перезарядка."""
            self._rounds = rounds
        
        ...
    ```

    Как видно из примера, теперь в методе игрока, отвечающего за атаку,
    можно просто вызвать метод normal_strike вне зависимости от того,
    что экипировано, хотя реализации этих методов и в целом классы
    оружия разные и имеют свои особенности.
________________________________________________________________________

4. И снова вернемся к абстракции. На самом деле, помимо описанного ранее
    смысла, абстракция также имеет и проистекающее из наследования и
    полиморфизма иное применение, а именно как объединяющая единица.
    Если есть классы, имеющие схожий смысл и схожие методы, но, кроме
    того, имеющие и различия, то можно для них создать абстрактный
    класс, объединяющий схожие вещи. Т.о. схожие вещи не придется
    описывать несколько раз, как и в наследовании, и для них можно будет
    задать общий интерфейс, как и в полиморфизме. Это и есть основной
    смысл и назначение абстракции как принципа ООП.

    Например: пусть в нашей игре есть меч, топор, молот, лук, пистолет и
    автомат. Тогда хорошим решением будет создать абстрактный класс
    "Оружие", где можно прописать получение значений атрибутов веса,
    урона, а также абстрактный метод как общий интерфейс для обычной
    атаки. Затем создать еще 2 унаследованных от "Оружия" класса
    "Ближнебойного оружия" и "Дальнобойного оружия", описывающее их
    особенности. А затем от этих двух наследовать классы конкретных
    оружий.

    Код:

    ```python
    from abc import abstractmethod

    class Weapon:
        """Абстрактный класс оружия."""

        def __init__(self, weight, damage):
            self._weight = weight
            self._damage = damage
        
        @abstractmethod
        def normal_strike(self, enemy):
            """Обычная атака."""
            pass

        # здесь и далее позволю себе не вдаваться в подробности кода и
        # отмечу такие места троеточием
        ...
        
    
    class MeleeWeapon(Weapon):  # наследуется от абстрактного Weapon
        """Абстрактный класс ближнебойного оружия."""

        def normal_strike(self, enemy):
            """Обычная атака."""
            ...
    

    class RangeWeapon(Weapon):  # наследуется от абстрактного Weapon
        """Абстрактный класс дальнобойного оружия."""

        self._MAX_ROUNDS: int

        def __init__(self, weight, damage):
            super().__init__(weight, damage)
            self._rounds = self._MAX_ROUNDS

        def normal_strike(self, enemy):
            """Обычная атака."""
            ...

        def reload(self, rounds):
            """Перезарядка."""
            ...
    

    class Sword(MeleeWeapon):  # наследуется от абстрактного MeleeWeapon
        """Класс меча."""
        ...
    

    # и т.д. по ближнебойным оружиям
    ...


    class Bow(RangeWeapon):  # наследуется от абстрактного RangeWeapon
        """Класс лука."""
        ...
    
    
    # и т.д. по дальнобойным оружиям
    ...
    ```

    И позволю себе доп. заметку. Абстракцию часто не упоминают как
    принцип, т.к. он является скорее следствием от наследования и
    полиморфизма, чем самостоятельным принципом. Тем не менее, на самом
    деле все принципы связаны между собой и по отдельности в контексте
    ООП имеют мало смысла. Абстракция - такой же полноправный принцип,
    как и прочие, и не стоит его пропускать.
________________________________________________________________________

### KISS, DRY, YAGNI И ДР. ###

Данные принципы являются общеупотребимыми в программировании, а не
только в контексте ООП. Основные из них вынесены в названии - KISS, DRY
и YAGNI. Кроме того, еще одним основным принципом является SOLID, но
он представляет собой более комплексную единицу и по этой причине
вынесен в отдельную подтему. Обычно эти 4 принципа и описываются или
указываюся. Но кроме них есть еще несколько полезных полезных принципов,
предложенных в данной подтеме конспекта.

Основное назначение всех этих принципов - эффективная, удобная и
понятная разработка программ.
________________________________________________________________________

1. **KISS** - Keep It Simple, Stupid - "будь проще". Данный принцип
    призывает не переусложнять код: не стоит придумывать решение
    сложнее, чем необходимо. Содержит в себе также следующие
    утверждения:
    - Простые системы надежнее всего работают.
    - Не стоит переизобретать колесо.

2. **DRY** - Don't Repeat Yourself - "не повторяйся". Не стоит
    дублировать код, иначе его сложнее поддерживать, а изменение в одном
    экземпляре приведет к потребности искать и изменять в остальных.
    Кратко говоря, бездумный копипаст - это плохая практика. Лучше
    вместо этого поискать решение среди имеющихся инструментов или
    написать ф-цию, класс и т.д.

3. **YAGNI** - You Aren't Gonna Need It - "тебе это не понадобится". Не
    писать и не оставлять то, что понадобится в будущем или было нужно
    раньше, но сейчас не используется. Писать и оставлять только то, что
    нужно сейчас. Захламленный неиспользуемыми блоками код усложняет его
    поддержку.

4. **BDUF** - Dig Design Up Front - "глобальное проектирование прежде
    всего". Прежде чем переходить к реализации, стоит все хорошо
    продумать. Составить план, схему проекта, продумать архитектуру,
    провести аналитику и проч. - и только тогда приступать к разработке.

5. **APO** - Avoid Premature Optimization - "избегай преждевременной
    оптимизации". Сильно связан с KISS и YAGNI, т.к. нарушение APO чаще
    всего нарушает и их. Призывает оптимизировать только по необх-ти и
    действительной полезности, а не преждевременно. Кроме того,
    напоминает, что важнее сделать поддерживаемый и рабочий код в
    заданные сроки, чем максимально оптимизированный.

6. **Бритва Оккама** - "не следует множить сущее без необходимости".
    Также своего рода наследник KISS и YAGNI, говорящий не создавать
    сущности без необходимости. Это относится как к неиспользуемым
    сущностям на будущее, так и используемым, но без необх-ти на то
    усложняющим код - "сущность ради сущности".
________________________________________________________________________

Данные принципы важны, но стоит учитывать ситуацию и контекст. Каждый из
принципов может быть нарушен в зав-ти от ситуации. Например:

- SOLID, описанный далее, часто в некотором смысле конфликтует с KISS,
    DRY и YAGNI, так что приходится выбирать. Чаще всего в такой
    ситуации лучшее решение будет за SOLID.
- DRY часто нарушается в больших проектах, а обдуманный копипаст с
    последующим улучшением бывает крайне полезен.
- BDUF - не всегда получается все продумать наперед, а дедлайны не дадут
    размышлять над этим вечно.
- YAGNI, APO, Оккама - в реальности хватает ситуаций, когда придется
    идти поперек и делать раньше, чем нужно - а именно сразу,
    непосредственно в течение текущей разработки, а не в последующем в
    ходе улучшений кода; с продумыванием наперед прямо в процессе, а не
    заранее.

Поэтому не стоит бояться их нарушить, это нормально и крайне часто имеет
место быть, но делать это надо обдуманно. Кроме, пожалуй, SOLID, который
в крупных проектах нарушать крайне нежелательно.
________________________________________________________________________

### SOLID ###

SOLID - не столько принцип проектирования программ, сколько их набор.
Содержит в себе 5 принципов (по одному на букву):

- **S**: Single Responsibility Principle (Принцип единственной
    ответственности).
- **O**: Open-Closed Principle (Принцип открытости-закрытости).
- **L**: Liskov Substitution Principle (Принцип подстановки Барбары
    Лисков).
- **I**: Interface Segregation Principle (Принцип разделения
    интерфейса).
- **D**: Dependency Inversion Principle (Принцип инверсии зависимостей).

Разберем каждый из них в отдельности.
________________________________________________________________________

***Принцип единственной ответственности*** (Single Responsibility
Principle, SRP) - каждая программная сущность (ф-ция, класс, модуль и
т.п.) должна быть ответственна за что-то одно. Иначе возникнут проблемы
как при чтении кода, так и при поддержке.

> **ПРИМЕР:** Допустим, мы разрабатываем простенькую RPG игру. Персонаж
игрока может прокачиваться, иметь различную экипировку, перемещаться,
бить врагов и наносить им урон.

- Плохая практика по SRP: дать классу игрока сразу и функционал
    перемещения/атаки/прокачки, и обработки нанесенного урона врагам, и
    сохранение новых статов и экипировки в к-л постоянном хранилище,
    например, БД. Все это разные задачи.

- Хорошая практика по SRP: оставить классу игрока вещи, нужные сугубо
    под задачи класса игрока: здоровье, управление, характеристики,
    слоты экипировки (хотя поседнее иногда имеет смысл вынести в
    отдельный класс, в зав-ти от сложности механик игры). Описание
    отдельных частей экипировки - в отдельные классы этих эл-тов.
    Обработка урона противникам - в класс противников. А сохранение
    данных - в отдельный класс менеджера сохранений или менеджера БД.
________________________________________________________________________

***Принцип открытости-закрытости*** (Open-Closed Principle, OCP) -
программные сущности должны быть открыты для расширения, но не для
модификации. Т.е. надо писать сущности так, чтобы их можно было
расширить новым функционалом в случае необх-ти, не меняя старый
функционал, только через добавление новых компонентов.

На практике OCP реализуется через наследование, интерфейсы, абстракции и
полиморфизм. Вместо изменения существующего кода добавляются новые
классы и функции.

> **ПРИМЕР:** В нашей игре есть разные мечи и топоры.

- Плохая практика по OCP: обрабатывать урон и накладываемые эффекты от
    каждого меча в коде метода "атаковать" игрока (что-то вроде "если
    экипирован обычный меч, то урон = 10, эффектов ноль; а если...").
    Мало того, что это нарушает и принцип SRP, так еще и при каждом
    добавлении нового меча или топора придется расширять этот список
    случаев, а читать и поддерживать такой код будет все сложнее и
    сложнее, особенно при балансе хар-к оружия.

- Хорошая практика по OCP: создать классы "Меч" и "Топор" с принимаемой
    хар-кой "урон" (для описания разных мечей и топоров одним
    соответствующим классом и по необх-ти - наследоваться от них для
    особых случаев и накладывания статусов на противника). После этого в
    соответствии с полиморфизмом ООП добавить метод или свойство в эти
    классы, возвращающее единообразно все необходимое для атаки, а из
    метода "атаковать" игрока вызывать этот метод или свойство. Тогда
    вне зав-ти от кол-ва оружий метод "атаковать" игрока не будет
    меняться, а функционал оружий будет лежать в определенном месте,
    упрощая поддержку и читаемость.
________________________________________________________________________

***Принцип подстановки Барбары Лисков*** (Liskov Substitution Principle,
LSP) - объекты в программе должны быть заменяемы их наследниками без
изменения корректности программы. Подкласс не должен нарушать ожидаемое
поведение программы. По сути в этом принципе раскрывается одна из сторон
полиморфизма.

> **ПРИМЕР:** Пусть у нас в игре есть разные мечи. Базовый меч дает
возм-ть производить только обычную атаку. У него есть модифицированные
версии: у зачарованного меча помимо обычной атаки есть специальная атака
с наложением на противника эффекта "горение", а у острого меча есть
только обычная атака, но она накладывает эффект "кровотечение". Классы
этих мечей наследуются от обычного меча.

- Плохая практика по LSP: ввести новый метод для обычной атаки,
    проигнорировав старый (что приведет к тому, что, наример, при замене
    обычного меча на острый игрок продолжит неожиданно быть без
    наложения статуса "кровотечение", обращаясь к старому интерфейсу),
    удалить старый метод обычной атаки (что, ожидаемо, приведет к ошибке
    при замене) или переписать метод обычной атаки там, где не надо
    (например, в зачарованном мече тогда обычная атака превратится во
    что-то иное, что не соответствует ТЗ). Кроме того, при появлении
    нового оружия, у которого и вовсе не должно быть функции обычной
    атаки, будет плохим решением наследовать класс такого оружия от
    класса базового меча, по аналогии с удалением метода или
    игнорированием его существования.

- Хорошая практика по LSP: у зачарованного меча не трогать метод обычной
    атаки, создать новый метод для "поджигающего" удара; у острого меча
    переписать метод обычной атаки с наложением статуса, не создавать
    новых методов. Если появляется новое оружие без обычной атаки -
    создать новый базовый класс, а не наследоваться от базового меча.
________________________________________________________________________

***Принцип разделения интерфейса*** (Interface Segregation Principle,
ISP) - классы программы не должны зависеть от тех методов, которые он не
используют. Создавайте узкоспециализированные интерфейсы. Вместо одного
большого интерфейса лучше создавать несколько маленьких — каждый со
своей задачей. За счёт такого подхода классы могут реализовывать только
те методы, что действительно нужны для их работы.

> **ПРИМЕР:** Пусть в нашей игре есть мечи и пистолеты.

- Плохая практика по ISP: создать класс Weapon, который будет содержать
    в себе атрибуты "урон", "кол-во патронов" и методы "атаковать" и
    "перезарядка". Для пистолетов такой набор хорош, и он реализует все,
    но для мечей параметр "кол-во патронов" и метод "перезарядка" не
    нужны и будут болтаться без дела.

- Хорошая практика по ISP: создать класс Weapon, содержащий атрибут
    "урон" и метод "атаковать". От него унаследовать класс мечей без
    изменений и класс пистолетов, добавив в последний атрибут "кол-во
    патронов" и метод "перезарядка".
________________________________________________________________________

***Принцип инверсии зависимостей*** (Dependency Inversion Principle,
DIP) - компоненты верхнего уровня не должны зависеть от компонентов
нижнего уровня. Иными словами, абстракции не должны зависеть от деталей.
Детали должны зависеть от абстракций.

> **ПРИМЕР:** В нашей игре есть мечи. Планируется в будущем добавить
    молоты. Кроме того, локальное сохранение ведется сейчас на базе
    PostgreSQL, но тестировка показала, что у целевой аудитории могут
    быть проблемы с ним. Несмотря на то, что PostgreSQL
    предпочтительнее, для аудитории с проблемами с ним хочется добавить
    автоматическую смену на SQLite.

- Плохая практика по DIP: в классе игрока жестко задать экземпляр класса
    "Меч" в экипировку, менять только характеристики при смене меча.
    Тогда при введении молотов придется тяжко, да и без более высокого
    уровня абстракции это не реализуемо без костылей. Аналогично и с
    выбором реализации SQL - если оставить жесткую привязку к методам
    работы с PostgreSQL, введение переключения на SQLite станет той еще
    проблемой.

- Хорошая практика по DIP: абстракция "Оружие", от него наследовать
    "Меч", класс игрока взаимодействует с методами абстракции "Оружие".
    Молот тогда введется как наследник "Оружия". Для БД - ввести
    абстракцию "Менеджер БД", а от него наследовать конкретные
    реализации.
________________________________________________________________________

Можно заметить, что принципы SOLID тесно связаны как между собой, так и
с другими принципами (ООП, KISS, YAGNI и т.д.), что нарушение одного
ведет к нарушению другого или даже нескольких других. Т.о. SOLID
частично дополняет, частично вбирает в себя и другие принципы и идет с
ними неразрывно.

С другой стороны, в некоторых местах он может конфликтовать с другими
принципами, напирая на будущие наработки или нарочито более сложное
исполнение. И хотя такое имеет место быть, SOLID считается более важной
практикой в крупных проектах, от которой лучше не отходить.

Тем не менее, все ситуативно, принципы не абсолютно конкретны, носят
рекомендательный характер, а конфликтующие с ними практики не являются
табу и могут иметь место быть в тех или иных задачах.
________________________________________________________________________

# ПАТТЕРНЫ #

Паттерны (или шаблоны) проектирования описывают типичные способы решения
часто встречающихся проблем при проектировании программ. Представляют
собой лучшие и самые популярные практики, т.о. повышая читаемость,
поддерживаемость и эффективность кода.

Подразделяются на 3 вида по назначению: порождающие, структурные и
поведенческие.
________________________________________________________________________

### ПОРОЖДАЮЩИЕ ###

Отвечают за удобное и безопасное создание новых объектов или даже целых
семейств объектов.
________________________________________________________________________

### <u> Абстрактная фабрика </u> ###

*Абстрактная фабрика* (Abstract factory) - это порождающий паттерн
проектирования, который позволяет создавать семейства связанных
объектов, не привязываясь к конкретным классам создаваемых объектов.

<u>Используется</u>: Когда система не должна зависеть от способа
создания новых объектов, при этом создаваемые объекты должны
использоваться вместе и являются взаимосвязанными.

- Когда бизнес-логика программы должна работать с разными видами
    связанных друг с другом продуктов, не завися от конкретных классов
    продуктов. Абстрактная фабрика скрывает от клиентского кода
    подробности того, как и какие конкретно объекты будут созданы. Но
    при этом клиентский код может работать со всеми типами создаваемых
    продуктов, поскольку их общий интерфейс был заранее определён.

- Когда в программе уже используется паттерн Фабричный метод, но
    очередные изменения предполагают введение новых типов продуктов. В
    хорошей программе каждый класс отвечает только за одну вещь. Если
    класс имеет слишком много фабричных методов, они способны затуманить
    его основную ф-цию. Поэтому имеет смысл вынести всю логику создания
    продуктов в отдельную иерархию классов, применив Абстрактную
    фабрику.

<u>Преимущества</u>:

- Гарантирует сочетаемость создаваемых продуктов.
- Избавляет клиентский код от привязки к конкретным классам продуктов.
- Выделяет код производства продуктов в одно место, упрощая поддержку
    кода.
- Упрощает добавление новых продуктов в программу.
- Реализует принцип открытости/закрытости.

<u>Недостатки</u>:

- Усложняет код программы из-за введения множества дополнительных
    классов.
- Требует наличия всех типов продуктов в каждой вариации.

<u>Пример</u>: Пусть у нас есть некоторый производитель различных
автомобилей (есть версии городских авто, внедорожников, спорткаров и
т.п.), которые собираются из частей: кузов, салон, двери, колеса и т.п.
Довольно резонно, что эти части взаимосвязаны, т.к. в спорткар не
поместится салон внедорожника, а на внедорожник не нужны колеса от
спорткара.

Решение: Создать абстрактные классы для эл-тов авто: кузов, салон, двери
и т.п. Создать классы конкретных исполнений для городских,
внедорожников, спорткаров и т.п. После этого применить паттерн
Абстрактная фабрика: создать класс абстрактной фабрики авто с методами
"создать кузов", "создать двери" и т.п., возвращающими экземпляры
абстрактных классов для эл-тов авто. От абстрактной фабрики унаследовать
классы конкретных фабрик авто с теми же методами, но с конкретными
реализациями для авто и с использованием классов конкретных исполнений
эл-тов авто. И теперь для производителя для создания конкретного авто
достаточно заиметь атрибут под фабрику, принимающего абстрактную фабрику
или ее дочерние фабрики, и менять фабрику в зав-ти от заказа, не меняя
интерфейс.

Код:

```python
class Body:
    ...

class JeepBody(Body):
    ...

class SportBody(Body):
    ...

...  # и прочие кузова для видов авто

# аналогично поступим для салона и колес

class Interior:
    ...

...

class Wheels:
    ...

...

# класс авто содержит в себе кузов, салон и колеса
# опустим создание геттеров и сеттеров для большего фокуса на теме
class Car:
    def __init__(self, body, interior, wheels):
        self.body = body
        self.interior = interior
        self.wheels = wheels

# а теперь фабрики
class CarFactory:
    @abstractmethod
    def create_body(self) -> Body:
        pass
    
    @abstractmethod
    def create_interior(self) -> Interior:
        pass
    
    @abstractmethod
    def create_wheels(self) -> Wheels:
        pass
    
    def create_car(self) -> Car:
        car = Car(
            body=self.create_body(),
            interior=self.create_interior(),
            wheels=self.create_wheels()
        )
        return car

class JeepCarFactory(CarFactory):
    def create_body(self) -> JeepBody:
        return JeepBody()  # добавить параметры, если нужно
    
    def create_interior(self) -> JeepInterior:
        return JeepInterior()
    
    def create_wheels(self) -> JeepWheels:
        return JeepWheels()

... # и аналогично для спорткара

# класс производителя авто
class CarManufactory:
    def __init__(self, factory):
        self._factory = factory
    
    def change_factory(self, factory):
        self._factory = factory
    
    def produce_car(self) -> Car:
        return self._factory.create_car()

# перейдем к использованию
# пусть будет заказ на 10 внедорожников и 20 спорткаров
manufactory = CarManufactory(factory=CarFactory())

# джипы
manufactory.change_factory(JeepFactory())
for _ in range(10):
    manufactory.produce_car()

# спорткары
manufactory.change_factory(SportFactory())
for _ in range(20):
    manufactory.produce_car()
```

Код выше представлен для наглядности, но не является самым правильным
решением.
________________________________________________________________________

### <u> Строитель </u> ###

*Строитель* (Builder) — это порождающий паттерн проектирования, который
позволяет создавать сложные объекты пошагово. Строитель даёт возможность
использовать один и тот же код строительства для получения разных
представлений объектов.

Как паттерн строитель содержит в себе следующих участников:

- Builder - определяет интерфейс конструирования продукта по частям.
- Director - управляет процессом создания, не зная, какой продукт будет
    создан в результате.
- ConcreteBuilder - конкретный строитель, который создает только
    известный ему объект класса Product.

Довольно тесно связан с Абстрактной фабрикой по назначению. Тем не
менее, Строитель концентрируется на построении сложных объектов шаг за
шагом, когда Абстрактная фабрика специализируется на создании семейств
связанных продуктов. Строитель возвращает продукт только после
выполнения всех шагов, а Абстрактная фабрика возвращает продукт сразу
же.

<u>Используется</u>: Когда процесс создания нового объекта не должен
зависеть от того, из каких частей этот объект состоит и как эти части
связаны между собой, при этом необходимо обеспечить получение различных
вариаций объекта в процессе его создания.

- Когда вы хотите избавиться от «телескопического конструктора».
    Например, у вас есть один конструктор с десятью опциональными
    параметрами. Паттерн Строитель позволяет собирать объекты пошагово,
    вызывая только те шаги, которые вам нужны. А значит, больше не нужно
    пытаться «запихнуть» в конструктор все возможные опции продукта.

- Когда ваш код должен создавать разные представления какого-то объекта.
    Например, деревянные и железобетонные дома. Строитель можно
    применить, если создание нескольких представлений объекта состоит из
    одинаковых этапов, которые отличаются в деталях.

- Когда вам нужно собирать сложные составные объекты, например, деревья
    Компоновщика. Строитель конструирует объекты пошагово, а не за один
    проход. Более того, шаги строительства можно выполнять рекурсивно. А
    без этого не построить древовидную структуру, вроде Компоновщика.

> **ЗАМЕТКА!** Мало используется в Python, т.к. изначально решает
проблему отсутствия именованных аргументов и аргументов по умолчанию,
которой в Python нет. Подобное решается в Python через фабричный метод и
именованные аргументы со значениями по умолчанию. Тем не менее, и в
Python паттерн Строитель иногда имеет место быть.

<u>Преимущества</u>:

- Позволяет создавать продукты пошагово.
- Позволяет использовать один и тот же код для создания различных
    продуктов.
- Изолирует сложный код сборки продукта от его основной бизнес-логики.

<u>Недостатки</u>:

- Усложняет код программы из-за введения дополнительных классов.
- Клиент будет привязан к конкретным классам строителей, так как в
    интерфейсе директора может не быть метода получения результата.

<u>Пример</u>: Пусть у нас есть некоторый производитель различных
автомобилей (есть версии городских авто, внедорожников, спорткаров и
т.п.), которые собираются из частей: кузов, салон, колеса, которые могут
отличаться в пределах одного типа авто, а также могут содержать доп.
элементы наподобие GPS, подогрева сидений, режима 4WD и проч.

Решение: Создать класс строителя, который задаст интерфейс с методами
установки ч-л в авто, сброса авто и выдачи результата. Создать
конкретные классы строителей для отдельных видов авто. Создать класс
директора со схемами сборки для конкретного авто. Избежим также
недостаток с привязкой к конкретным строителям через знание директором,
что получается, и возврат через него.

Код:

```python
# класс авто
# опустим создание геттеров и сеттеров для большего фокуса на теме
class Car:
    def __init__(self):
        self.body = None
        self.interior = None
        self.wheels = None
        self.extra_features = set()  # для упрощения доп. эл-ты будем
                                     # хранить в мн-ве в виде строк

# абстрактный строитель авто
class Builder:
    def __init__(self):
        self._car = Car()
    
    def reset(self):
        self._car = Car()
    
    def get_car(self) -> Car:
        car = self._car
        self.reset()
        return car

    @abstractmethod
    def set_body(self):
        pass

    @abstractmethod
    def set_wheels(self):
        pass
    
    def set_interior(self, interior):
        self._car.interior = interior
    
    def add_GPS(self):
        self._car.extra_features.add('GPS')
    
    def add_termal_control(self):
        self._car.extra_features.add('Termal control')

# конкретный строитель обычных городских авто
class CommonBuilder(Builder):
    def set_body(self):
        # здесь и далее будем использовать экземпляры классов для
        # отдельных эл-тов, которые, представим, были описаны ранее
        self._car.body = CommonBody(...)

    def set_wheels(self):
        self._car.wheels = CommonWheels(...)

# конкретный строитель внедорожников
class JeepBuilder(Builder):
    def set_body(self):
        self._car.body = JeepBody(...)

    def set_wheels(self):
        self._car.wheels = JeepWheels(...)

    def add_4WD(self):
        self._car.extra_features.add('4WD')

# конкретный строитель спорткаров
class SportBuilder(Builder):
    def set_body(self):
        self._car.body = SportBody(...)

    def set_wheels(self):
        self._car.wheels = SportWheels(...)

    def add_spoiler_control(self):
        self._car.extra_features.add('Spoiler control')

# директор
class Director:
    def __init__(self):
        self._common_builder = CommonBuilder()
        self._jeep_builder = JeepBuilder()
        self._sport_builder = SportBuilder()
    
    # обычное авто без доп. фич
    def make_common_car(self) -> Car:
        self._common_builder.set_body()
        self._common_builder.set_wheels()
        self._common_builder.set_interior(CommonInterior(...))
        return self._common_builder.get_car()
    
    # обычное авто с доп. фичами
    def make_premium_car(self) -> Car:
        self._common_builder.set_body()
        self._common_builder.set_wheels()
        self._common_builder.set_interior(PremiumInterior(...))
        self._common_builder.add_GPS()
        self._common_builder.add_termal_control()
        return self._common_builder.get_car()
    
    # джип
    def make_jeep(self) -> Car:
        self._jeep_builder.set_body()
        ...
    
    # спорткар
    def make_sportcar(self) -> Car:
        self._sport_builder.set_body()
        ...
    
# перейдем к использованию
# пусть заказ на 10 джипов и 20 спорткаров
director = Director()

# джипы
for _ in range(10):
    director.make_jeep()

# спорткары
for _ in range(20):
    director.make_sportcar()
```

Код выше представлен для наглядности, но не является самым правильным
решением.
________________________________________________________________________

### <u> Фабричный метод </u> ###

*Фабричный метод* (Factory method) — это порождающий паттерн, который
определяет общий интерфейс для создания объектов в суперклассе, позволяя
подклассам изменять тип создаваемых объектов.

<u>Используется</u>:

- Когда заранее неизвестны типы и зависимости объектов, с которыми
    должен работать ваш код. Фабричный метод отделяет код производства
    продуктов от остального кода, который эти продукты использует.
- Когда вы хотите дать возможность пользователям расширять части вашего
    фреймворка или библиотеки. Пользователи могут расширять классы
    вашего фреймворка через наследование. Но как сделать так, чтобы
    фреймворк создавал объекты из этих новых классов, а не из
    стандартных? Решением будет дать пользователям возможность расширять
    не только желаемые компоненты, но и классы, которые создают эти
    компоненты. А для этого создающие классы должны иметь конкретные
    создающие методы, которые можно определить.
- Когда вы хотите экономить системные ресурсы, повторно используя уже
    созданные объекты, вместо порождения новых.

<u>Преимущества</u>:

- Избавляет класс от привязки к конкретным классам продуктов.
- Выделяет код производства продуктов в одно место, упрощая поддержку кода.
- Упрощает добавление новых продуктов в программу.
- Реализует принцип открытости/закрытости.

<u>Недостатки</u>:

- Может привести к созданию больших параллельных иерархий классов, так
    как для каждого класса продукта надо создать свой подкласс
    создателя.

<u>Пример</u>: у нас есть логистика через грузовики и корабли, а также
вводится транспортировка через поезда. Нужно организовать планировщик
логистических перевозок.

Решение: создать абстрактный логистический класс, у которого будет
абстрактный метод "создать транспорт", возвращающий абстрактный
транспорт. Для каждого конкретного вида транспорта создать свой
логистический класс, наследуемый от абстрактного, уточняющий метод
"создать транспорт" под данный транспорт.

Код:

```python
# транспорт и его дочерние виды
class Transport:
    @abstractmethod
    def deliver(self, delivery_info):
        pass

class Truck(Transport):
    def deliver(self, delivery_info):
        ...  # реализация доставки грузовиком

class Ship(Transport):
    def deliver(self, deliver_info):
        ...

# абстрактный логистический класс и его конкретные дочерние классы
class Logistics:
    def plan_delivery(self, delivery_info):
        transport = self.create_transport()
        transport.deliver(delivery_info)
    
    @abstractmethod
    def create_transport(self) -> Transport:
        pass

class TruckLogistics(Logistics):
    def create_transport(self) -> Truck:
        return Truck()

class ShipLogistics(Logistics):
    def create_transport(self) -> Ship:
        return Ship()

# использование
# пусть будет заказ на доставки, описанные в truck_delivery_info и
# ship_delivery_info
truck_logistics = TruckLogistics()
ship_logistics = ShipLogistics()

truck_delivery_info = [[...], ..., [...]]  # пусть будет 10 доставок
ship_delivery_info = [[...], ..., [...]]   # пусть будет 20 доставок

for delivery_info in truck_delivery_info:
    truck_logistics.plan_delivery(delivery_info)

for delivery_info in ship_delivery_info:
    ship_logistics.plan_delivery(delivery_info)
```

В таком виде реализация удобнее и читаемее, чем в потенциальном
"беспаттерновом" подходе. Кроме того, расширяемее, ведь для введения
новой доставки на поездах достаточно задать классы `Train` и
`TrainLogistics`, в последнем из которых нужно переопределить всего один
метод - тот самый, фабричный метод create_transport.
________________________________________________________________________

### <u> Прототип </u> ###

*Прототип* (Prototype) — это порождающий паттерн проектирования, который
позволяет копировать объекты, не вдаваясь в подробности их реализации.

<u>Используется</u>:

- Когда класс порождаемого объекта определяется в момент выполнения.
- Когда желательно избежать наследования создателя объекта. В этом
    случае, Прототип является конкурентом Абстрактной фабрики.
- Когда клонирование объекта является более предпочтительным вариантом
    нежели его создание и инициализация с помощью конструктора.
- Когда создание копии объекта проще и быстрее, чем порождение его
    стандартным путем.

> **ЗАМЕТКА!** В Python в ряде случаев не исп-ся. Прототип особенно
полезен в статически типизированных языках вроде C++, где классы не
являются объектами. В Python же можно передавать и классы, и к-н
фабричные ф-ции как объекты, что позволяет не думать о проблеме, которой
нет. Тем не менее, в том виде, в котором представлен далее, Прототип
имеет место быть.

<u>Преимущества</u>:

- Позволяет клонировать объекты, не привязываясь к их конкретным
    классам.
- Меньше повторяющегося кода инициализации объектов.
- Ускоряет создание объектов.
- Альтернатива созданию подклассов для конструирования сложных объектов.

<u>Недостатки</u>:

- Сложно клонировать составные объекты, имеющие ссылки на другие
    объекты.

<u>Пример</u>: Допустим, у нас есть производство автомобилей. Но есть
проблема: каждый раз, когда создается автомобиль, требуются отдельные
долгие расчеты, хотя для автомобилей одного и того же класса результат
этих расчетов идентичен. При этом мы хотим сохранить возможность просто
добавлять новые классы авто на будущее.

Или другой пример, более подходящий, но "в лоб" и более отдаленный от
программирования. Допустим, у нас есть производство автомобилей. Но есть
проблема: каждый раз, когда создается автомобиль, нужно произвести
долгие сварочные работы, отливку деталей и проч. При этом мы узнали, что
ученые изобрели клонирование, которое пускай и занимает какое-то время,
но показывает себя заметно быстрее, чем сварка и отливка.

Решение: Для каждого класса авто создать прототип, а затем от него
клонироваться.

Код:

```python
# абстрактный класс с поддержкой клонирования
class Car:
    @abstractmethod
    def clone(self) -> Car:
        pass

# конкретный класс с поддержкой клонирования
class Jeep(Car):
    def __init__(self, some_data=None):
        if some_data is None:
            some_data = ...  # долгий расчет
        self._some_data = some_data
    
    def clone(self) -> Jeep:
        return Jeep(some_data=self._some_data)

# то же для других конкретных авто
class Sportcar(Car):
    ...

class CommonCar(Car):
    ...

# теперь пример использования
# пусть заказ на 10 джипов и 20 спорткаров
prototype_jeep = Jeep()
prototype_sportcar = Sportcar()
prototype_common = CommonCar()

for _ in range(10):
    prototype_jeep.clone()

for _ in range(20):
    prototype_sportcar.clone()
```

Другой пример: Мы хотим создать несколько разных джипов, имеющих одни и
те же методы и атрибуты, но разное их наполнение. При этом мы не хотим
по к-л причине создавать под них множество разных классов.

Решение: Альтернативой будет создать класс Jeep, добавить в него метод
"клонировать", для разных реализаций джипов создать прототипы, а от них
уже клонироваться.

Данные примеры далеко не идеальны для демонстрации паттерна Прототип или
демонстрации хорошего кода, но показывают его структуру. Кроме того,
есть возможные вариации его реализации (см. Источники).
________________________________________________________________________

### <u> Одиночка (Синглтон) </u> ###

*Одиночка* (Singleton, Синглтон) — это порождающий паттерн
проектирования, который гарантирует, что у класса есть только один
экземпляр, и предоставляет к нему глобальную точку доступа.

<u>Используется</u>:

- Когда в программе должен быть единственный экземпляр какого-то класса,
    доступный всем клиентам (например, общий доступ к базе данных из
    разных частей программы). Одиночка скрывает от клиентов все способы
    создания нового объекта, кроме специального метода. Этот метод либо
    создаёт объект, либо отдаёт существующий объект, если он уже был
    создан.
- Когда вам хочется иметь больше контроля над глобальными переменными. В
    отличие от глобальных переменных, Одиночка гарантирует, что никакой
    другой код не заменит созданный экземпляр класса, поэтому вы всегда
    уверены в наличии лишь одного объекта-одиночки. При этом
    контролируется кол-во объектов в одном месте, так что по необх-ти
    можно ограничить создание к-л другим кол-вом экземпляров, а не
    только одним.

> **ЗАМЕТКА!** В Python не рекомендуется к использованию, потому что
решает проблему из C++, которой нет в Python. Для создания синглтона
достаточно создать переменную на уровне модуля и импортировать именно ее
\- получится глобальный единственный экземпляр, по сути синглтон.

<u>Преимущества</u>:

- Гарантирует наличие единственного экземпляра класса.
- Предоставляет к нему глобальную точку доступа.
- Реализует отложенную инициализацию объекта-одиночки.

<u>Недостатки</u>:

- Нарушает принцип единственной ответственности класса.
- Маскирует плохой дизайн.
- Проблемы многопоточности.
- Требует постоянного создания Mock-объектов при юнит-тестировании.

<u>Пример</u>: Храним все произведенные автомобили в БД. Организовать
единый доступ к БД из разных частей программы.

Решение: Использовать Синглтон, тогда он при создании нового экземпляра
будет возвращать один и тот же, и не придется плодить идентичные
сущности.

Код:

```python
class DBConnection:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    ...  # прочий полезный код

# использование
db_conn_1 = DBConnection()  # в одном месте (и мб даже скрипте проекта)
db_conn_2 = DBConnection()  # в другом месте (и мб даже скрипте проекта)

db_conn_1 is db_conn_2  # даст True
# т.о. экземпляр всего один, а ссылаются на него 2 переменные из разных
# мест проекта
```
________________________________________________________________________

### СТРУКТУРНЫЕ ###

Отвечают за построение удобных в поддержке иерархий классов.
________________________________________________________________________

### <u> Адаптер </u> ###



<u>Используется</u>:

<u>Преимущества</u>:

<u>Недостатки</u>:

<u>Пример</u>:

Решение:

Код:

```python

```
________________________________________________________________________

### <u> Мост </u> ###



<u>Используется</u>:

<u>Преимущества</u>:

<u>Недостатки</u>:

<u>Пример</u>:

Решение:

Код:

```python

```
________________________________________________________________________

### <u> Компоновщик </u> ###



<u>Используется</u>:

<u>Преимущества</u>:

<u>Недостатки</u>:

<u>Пример</u>:

Решение:

Код:

```python

```
________________________________________________________________________

### <u> Декоратор </u> ###



<u>Используется</u>:

<u>Преимущества</u>:

<u>Недостатки</u>:

<u>Пример</u>:

Решение:

Код:

```python

```
________________________________________________________________________

### <u> Фасад </u> ###



<u>Используется</u>:

<u>Преимущества</u>:

<u>Недостатки</u>:

<u>Пример</u>:

Решение:

Код:

```python

```
________________________________________________________________________

### <u> Приспособленец (Легковес) </u> ###



<u>Используется</u>:

<u>Преимущества</u>:

<u>Недостатки</u>:

<u>Пример</u>:

Решение:

Код:

```python

```
________________________________________________________________________

### <u> Заместитель </u> ###



<u>Используется</u>:

<u>Преимущества</u>:

<u>Недостатки</u>:

<u>Пример</u>:

Решение:

Код:

```python

```
________________________________________________________________________

### ПОВЕДЕНЧЕСКИЕ ###

Решают задачи эффективного и безопасного взаимодействия между объектами
программы.
________________________________________________________________________

### <u> Цепочка обязанностей </u> ###



<u>Используется</u>:

<u>Преимущества</u>:

<u>Недостатки</u>:

<u>Пример</u>:

Решение:

Код:

```python

```
________________________________________________________________________

### <u> Команда </u> ###



<u>Используется</u>:

<u>Преимущества</u>:

<u>Недостатки</u>:

<u>Пример</u>:

Решение:

Код:

```python

```
________________________________________________________________________

### <u> Интерпретатор </u> ###



<u>Используется</u>:

<u>Преимущества</u>:

<u>Недостатки</u>:

<u>Пример</u>:

Решение:

Код:

```python

```
________________________________________________________________________

### <u> Итератор </u> ###



<u>Используется</u>:

<u>Преимущества</u>:

<u>Недостатки</u>:

<u>Пример</u>:

Решение:

Код:

```python

```
________________________________________________________________________

### <u> Посредник </u> ###



<u>Используется</u>:

<u>Преимущества</u>:

<u>Недостатки</u>:

<u>Пример</u>:

Решение:

Код:

```python

```
________________________________________________________________________

### <u> Хранитель </u> ###



<u>Используется</u>:

<u>Преимущества</u>:

<u>Недостатки</u>:

<u>Пример</u>:

Решение:

Код:

```python

```
________________________________________________________________________

### <u> Наблюдатель </u> ###



<u>Используется</u>:

<u>Преимущества</u>:

<u>Недостатки</u>:

<u>Пример</u>:

Решение:

Код:

```python

```
________________________________________________________________________

### <u> Состояние </u> ###



<u>Используется</u>:

<u>Преимущества</u>:

<u>Недостатки</u>:

<u>Пример</u>:

Решение:

Код:

```python

```
________________________________________________________________________

### <u> Стратегия </u> ###



<u>Используется</u>:

<u>Преимущества</u>:

<u>Недостатки</u>:

<u>Пример</u>:

Решение:

Код:

```python

```
________________________________________________________________________

### <u> Шаблонный метод </u> ###



<u>Используется</u>:

<u>Преимущества</u>:

<u>Недостатки</u>:

<u>Пример</u>:

Решение:

Код:

```python

```
________________________________________________________________________

### <u> Посетитель </u> ###



<u>Используется</u>:

<u>Преимущества</u>:

<u>Недостатки</u>:

<u>Пример</u>:

Решение:

Код:

```python

```
________________________________________________________________________

# ИСТОЧНИКИ И ДОП. МАТЕРИАЛЫ #

1. [Сайт] **Статья по ООП от Яндекс Практикума**:
    [ссылка](https://practicum.yandex.ru/blog/obektno-orientirovannoe-programmirovanie/).
1. [Сайт] **Статья по KISS, DRY, YAGNI, SOLID и т.д. на Хабре**:
    [ссылка](https://habr.com/ru/companies/itelma/articles/546372/).
1. [Сайт] **Статьи о SOLID**:
    [ссылка](https://habr.com/ru/companies/ruvds/articles/426413/),
    [ссылка](https://blog.skillbox.by/kod/principy-solid-v-oop-chto-jeto-i-kak-ih-primenjat-skillbox-media/),
    [ссылка](https://timeweb.cloud/blog/solid-principy-i-ih-rol-v-razrabotke-po).
1. [Литература] **Э. Гамма, Р. Хелм, Р. Джонсон, Дж. Влиссидес ("Банда**
    **Четырех") - Паттерны ООП**.
1. [Сайт] **Шпаргалки по паттернам проектирования**:
    [ссылка](http://refactoringu.ru/ru/design-patterns/catalog.html),
    [ссылка](https://bool.dev/blog/detail/gof-design-patterns).
1. [Сайт] **Статьи о паттернах, которые не нужны в Python**:
    [ссылка](https://habr.com/ru/companies/piter/articles/939022/),
    [ссылка](https://habr.com/ru/companies/piter/articles/941606/).
________________________________________________________________________
