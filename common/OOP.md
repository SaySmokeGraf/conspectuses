________________________________________________________________________

# СОДЕРЖАНИЕ #

- > **[КРАТКАЯ ТЕОРИЯ](#краткая-теория)**
- > **[ПРИНЦИПЫ](#принципы)**
    1. > **[ОСНОВНЫЕ ПРИНЦИПЫ ООП](#основные-принципы-ооп)**
    1. > **[KISS, DRY, YAGNI И ДР.](#kiss-dry-yagni-и-др)**
    1. > **[SOLID](#solid)**
- > **[ПАТТЕРНЫ](#паттерны)**
- > **[ИСТОЧНИКИ И ДОП. МАТЕРИАЛЫ](#источники-и-доп-материалы)**
________________________________________________________________________

# КРАТКАЯ ТЕОРИЯ #

*Объектно-ориентированное программирование* (ООП) - это парадигма
разработки и подход к организации программ, основанный на концепции
объектов.

*Объект* (экземпляр класса) - сущность, обладающая состоянием и
поведением. Состояние описывается через *атрибуты* - хар-ки объекта.
Поведение описывается через *методы* - ф-ции внутри объекта, которые
позволяют ему взаимодействовать с собой, своими атрибутами и методами
или другой частью кода (будь то переменные, функции или другие объекты).

*Класс* - шаблон для создания объектов.

Код в ООП должен соответствовать основным принципам ООП, описанным в
разделе Принципы.
________________________________________________________________________

Преимущества ООП по сравнению с ФП:

- В парадигме объектов легче писать код. Удобно один раз создать класс
    или метод, а потом его использовать, без переписывания большого
    кол-ва строк кода.
- Код понятнее, а читать его гораздо проще. В парадигме ООП программа
    становится чуточку ближе к реальному миру с его различными
    объектами, состояниями и поведением, отчего код проще
    интерпретировать. Кроме того, код становится структурированнее.
- Код легче обновлять и поддерживать. Класс или метод достаточно
    изменить в одном месте, чтобы он изменился во всех наследуемых
    классах и объектах. Не нужно переписывать каждый объект отдельно.
- Код удобнее переиспользовать.
- Шаблоны проектирования (паттерны) и принципы - готовые решения и
    правила для хорошего кода.

Недостатки ООП по сравнению с ФП:

- Сложность в освоении больше, чем у функционального программирования.
- Громоздкость. Там, где в функциональном программировании хватит одной
    функции для небольшой программы, в ООП нужно создать класс, объект,
    методы и атрибуты. Но для больших программ это оборачивается плюсом
    в виде структурированности.
- Низкая производительность. Объекты потребляют больше памяти, чем
    простые функции и переменные.

Итого: ООП больше подходит для больших программ со сложной структурой, в
то время как для небольших программ предпочтительнее использовать ФП.
________________________________________________________________________

# ПРИНЦИПЫ #

В данном разделе описаны различные принципы в ООП. Некоторые из них
можно (и нужно) отнести ко всем популярным парадигмам программирования,
но в условиях ООП с его громоздкостью и опорой на объекты эти принципы
раскрываются заметно ярче, чем в ФП. Поэтому важно напомнить о них тут.
________________________________________________________________________

### ОСНОВНЫЕ ПРИНЦИПЫ ООП ###

Основные принципы ООП представляют собой важные черты данной парадигмы,
описывая самые базовые механизмы для правильности, эффективности и
удобства использования ООП.
________________________________________________________________________

0. *Абстракция* - возможность моделировать сущности и концепции, выделяя
    главное и опуская детали. С этой стороны абстракция - одна из основ
    ООП, чуть ли не самая базовая идея о классах, но в то же время
    говорящая нам не перегружать код тем, что не нужно (будто повторяя
    идеи другого известного принципа в программировании - YAGNI).

    Например: допустим, мы разрабатываем простенькую RPG игру, где игрок
    может пользоваться каким-то оружием. Пускай мы хотим добавить в игру
    меч. От реального меча нам много чего может быть нужно, конечно, но
    помня, что игра простенькая, навряд ли нам понадобится точный состав
    меча вплоть до процентов того или иного металла в сплаве. Нам навряд
    ли понадобятся и все возможные стили фехтования, и возможность им
    пользоваться не по назначению - подпирать стол или жонглировать. Для
    простенькой игры лучше иметь всего несколько анимаций, знать урон
    меча, по необх-ти - вес, да и все. За этим - выбор нужного,
    отсечение лишнего - и кроется абстракция.

    С этой стороны мы раскрыли абстракцию - как основу ООП и как
    некоторую родственную принципу YAGNI сущность. Но это еще не все, и
    мы вернемся к ней позже.
________________________________________________________________________

1. *Инкапсуляция* - данные, необходимые для работы объекта, должны
    находиться внутри объекта, а доступ к ним должен быть контролируем.

    Например: пусть в нашей игре есть меч. Хранить вес и урон каждого
    меча лучше в самом экземпляре класса "Меч", чем в каком-нибудь
    списке весов и уронов мече за пределами экземпляров. Кроме того,
    нельзя давать пользователю своевольно менять данные характеристики,
    но смотреть в любой момент - нужно.

    Код:

    ```python
    class Sword:
        """Класс меча."""

        def __init__(self, weight, damage):
            self._weight = weight
            self._damage = damage
        
        @property
        def weight(self):
            """Геттер веса меча."""
            return self._weight
        
        # но не добавяем сеттер для веса, т.к. не хотим, чтобы его
        # кто-то или что-то меняло

        @property
        def damage(self):
            """Геттер урона меча."""
            return self._damage
        
        # с сеттером для урона - аналогично сеттеру веса
    ```

    При этом при механиках облегчения мечей или увеличения урона при
    апгрейде уже нужно что-то придумывать и с сеттерами и описывать
    ограничения, когда можно изменить эти хар-ки, а когда - нельзя. Это
    все так же относится к контролю доступа к данным, который
    подразумевается в инкапсуляции.
________________________________________________________________________

2. *Наследование* - механизм, аналогичный реальному биологическому
    наследованию: есть родительский класс, и на его основе можно сделать
    дочерний класс. Каждый дочерний эл-т наследует методы и атрибуты,
    прописанные в родительском. Он может использовать их все, отбросить
    часть или добавить новые. При этом заново прописывать атрибуты и
    методы родительского класса в дочернем не нужно. Методы и атрибуты -
    своего рода аналогия геному в биологическом наследовании, а
    изменения и новшества в дочернем классе - аналогия мутациям или
    совершенствованиям.

    В то же время наследование как принцип косвенно говорит о том, что
    не стоит повторяться в подходящих под ситуацию "родитель-ребенок"
    случаях и описывать два таких класса отдельно - стоит использовать
    механику наследования.

    Например: пусть в нашей игре есть два меча. Один - обычный меч с
    обычным ударом. Второй - абсолютно такой же, но зачарованный, с
    возможностью использовать специальный удар, наносящий половину
    обычного урона, но накладывающий статус "горение". При этом все
    остальное идентично: есть обычный удар, те же анимации (кроме как
    при спец. приеме), те же атрибуты. В таком ключе лучше создать
    обычный меч как родительский класс, а зачарованный - как дочерний
    класс.

    Код:

    ```python
    # пусть за данной вырезкой находятся класс, описывающий
    # потенциального противника, у которого есть методы take_damage
    # (обрабатывает механику получения урона - кстати, также пример
    # инкапсуляции) и set_status (установить статус), а также классовые
    # константы, описывающие статусы наподобие горения

    class Sword:
        """Класс меча."""

        def __init__(self, weight, damage):
            self._weight = weight
            self._damage = damage
        
        def normal_strike(self, enemy):
            """Обычный удар."""
            enemy.take_damage(self._damage)
        
        # опустим описанные ранее геттеры для атрибутов
        ...
    

    class EnchantedSword(Sword):  # наследуется от Sword

        def fiery_strike(self, enemy):
            """Поджигающий удар."""
            enemy.take_damage(self._damage // 2)
            enemy.set_status(enemy.STATUS_BURN)
    ```

    После такого обьявления класс EnchantedSword инициализируется теми
    же атрибутами, что и Sword, а также имеет те же методы, но, кроме
    того, имеет дополнительный метод, отвечающий за "поджигающий" удар.
    Это и есть наследование.
________________________________________________________________________

3. *Полиморфизм* - принцип взаимозаменяемости схожих классов, говорящий,
    что схожим классам следует предоставлять одинаковый интерфейс для
    выполнения одинаковых по смыслу, но разных по исполнению действий.

    Например: в нашей игре есть не только меч, но и пистолет. Оба имеют
    обычную атаку, но меч просто производит атаку с уроном, а пистолет
    еще и тратит патрон из магазина. Тогда лучшим решением будет
    одинаково назвать методы для этой самой атаки, пускай реализация и
    разнится. В результате вне зависимости от того, какое оружие
    экипировано у игрока, можно будет обратиться к нему по одному и тому
    же методу и произвести нужную нам обычную атаку.

    Код:

    ```python
    class Sword:
        """Класс меча."""

        def __init__(self, weight, damage):
            self._weight = weight
            self._damage = damage
        
        def normal_strike(self, enemy):
            """Обычная атака."""
            enemy.take_damage(self._damage)
        
        ...
    

    class Pistol:
        """Класс пистолета."""

        self._MAX_ROUNDS = 10

        def __init__(self, weight, damage):
            self._weight = weight
            self._damage = damage
            self._rounds = self._MAX_ROUNDS
        
        def normal_strike(self, enemy):  # тот же, что и у Sword
            """Обычная атака."""
            if self._rounds:
                enemy.take_damage(self._damage)
                self._rounds -= 1
            else:
                print('Упс! Нет патронов в магазине!')
        
        def reload(self, rounds):
            """Перезарядка."""
            self._rounds = rounds
        
        ...
    ```

    Как видно из примера, теперь в методе игрока, отвечающего за атаку,
    можно просто вызвать метод normal_strike вне зависимости от того,
    что экипировано, хотя реализации этих методов и в целом классы
    оружия разные и имеют свои особенности.
________________________________________________________________________

4. И снова вернемся к абстракции. На самом деле, помимо описанного ранее
    смысла, абстракция также имеет и проистекающее из наследования и
    полиморфизма иное применение, а именно как объединяющая единица.
    Если есть классы, имеющие схожий смысл и схожие методы, но, кроме
    того, имеющие и различия, то можно для них создать абстрактный
    класс, объединяющий схожие вещи. Т.о. схожие вещи не придется
    описывать несколько раз, как и в наследовании, и для них можно будет
    задать общий интерфейс, как и в полиморфизме. Это и есть основной
    смысл и назначение абстракции как принципа ООП.

    Например: пусть в нашей игре есть меч, топор, молот, лук, пистолет и
    автомат. Тогда хорошим решением будет создать абстрактный класс
    "Оружие", где можно прописать получение значений атрибутов веса,
    урона, а также абстрактный метод как общий интерфейс для обычной
    атаки. Затем создать еще 2 унаследованных от "Оружия" класса
    "Ближнебойного оружия" и "Дальнобойного оружия", описывающее их
    особенности. А затем от этих двух наследовать классы конкретных
    оружий.

    Код:

    ```python
    from abc import abstractmethod

    class Weapon:
        """Абстрактный класс оружия."""

        def __init__(self, weight, damage):
            self._weight = weight
            self._damage = damage
        
        @abstractmethod
        def normal_strike(self, enemy):
            """Обычная атака."""
            pass

        # здесь и далее позволю себе не вдаваться в подробности кода и
        # отмечу такие места троеточием
        ...
        
    
    class MeleeWeapon(Weapon):  # наследуется от абстрактного Weapon
        """Абстрактный класс ближнебойного оружия."""

        def normal_strike(self, enemy):
            """Обычная атака."""
            ...
    

    class RangeWeapon(Weapon):  # наследуется от абстрактного Weapon
        """Абстрактный класс дальнобойного оружия."""

        self._MAX_ROUNDS: int

        def __init__(self, weight, damage):
            super().__init__(weight, damage)
            self._rounds = self._MAX_ROUNDS

        def normal_strike(self, enemy):
            """Обычная атака."""
            ...

        def reload(self, rounds):
            """Перезарядка."""
            ...
    

    class Sword(MeleeWeapon):  # наследуется от абстрактного MeleeWeapon
        """Класс меча."""
        ...
    

    # и т.д. по ближнебойным оружиям
    ...


    class Bow(RangeWeapon):  # наследуется от абстрактного RangeWeapon
        """Класс лука."""
        ...
    
    
    # и т.д. по дальнобойным оружиям
    ...
    ```

    И позволю себе доп. заметку. Абстракцию часто не упоминают как
    принцип, т.к. он является скорее следствием от наследования и
    полиморфизма, чем самостоятельным принципом. Тем не менее, на самом
    деле все принципы связаны между собой и по отдельности в контексте
    ООП имеют мало смысла. Абстракция - такой же полноправный принцип,
    как и прочие, и не стоит его пропускать.
________________________________________________________________________

### KISS, DRY, YAGNI И ДР. ###

Данные принципы являются общеупотребимыми в программировании, а не
только в контексте ООП. Основные из них вынесены в названии - KISS, DRY
и YAGNI. Кроме того, еще одним основным принципом является SOLID, но
он представляет собой более комплексную единицу и по этой причине
вынесен в отдельную подтему. Обычно эти 4 принципа и описываются или
указываюся. Но кроме них есть еще несколько полезных полезных принципов,
предложенных в данной подтеме конспекта.

Основное назначение всех этих принципов - эффективная, удобная и
понятная разработка программ.
________________________________________________________________________

1. **KISS** - Keep It Simple, Stupid - "будь проще". Данный принцип
    призывает не переусложнять код: не стоит придумывать решение
    сложнее, чем необходимо. Содержит в себе также следующие
    утверждения:
    - Простые системы надежнее всего работают.
    - Не стоит переизобретать колесо.

2. **DRY** - Don't Repeat Yourself - "не повторяйся". Не стоит
    дублировать код, иначе его сложнее поддерживать, а изменение в одном
    экземпляре приведет к потребности искать и изменять в остальных.
    Кратко говоря, бездумный копипаст - это плохая практика. Лучше
    вместо этого поискать решение среди имеющихся инструментов или
    написать ф-цию, класс и т.д.

3. **YAGNI** - You Aren't Gonna Need It - "тебе это не понадобится". Не
    писать и не оставлять то, что понадобится в будущем или было нужно
    раньше, но сейчас не используется. Писать и оставлять только то, что
    нужно сейчас. Захламленный неиспользуемыми блоками код усложняет его
    поддержку.

4. **BDUF** - Dig Design Up Front - "глобальное проектирование прежде
    всего". Прежде чем переходить к реализации, стоит все хорошо
    продумать. Составить план, схему проекта, продумать архитектуру,
    провести аналитику и проч. - и только тогда приступать к разработке.

5. **APO** - Avoid Premature Optimization - "избегай преждевременной
    оптимизации". Сильно связан с KISS и YAGNI, т.к. нарушение APO чаще
    всего нарушает и их. Призывает оптимизировать только по необх-ти и
    действительной полезности, а не преждевременно. Кроме того,
    напоминает, что важнее сделать поддерживаемый и рабочий код в
    заданные сроки, чем максимально оптимизированный.

6. **Бритва Оккама** - "не следует множить сущее без необходимости".
    Также своего рода наследник KISS и YAGNI, говорящий не создавать
    сущности без необходимости. Это относится как к неиспользуемым
    сущностям на будущее, так и используемым, но без необх-ти на то
    усложняющим код - "сущность ради сущности".
________________________________________________________________________

Данные принципы важны, но стоит учитывать ситуацию и контекст. Каждый из
принципов может быть нарушен в зав-ти от ситуации. Например:

- SOLID, описанный далее, часто в некотором смысле конфликтует с KISS,
    DRY и YAGNI, так что приходится выбирать. Чаще всего в такой
    ситуации лучшее решение будет за SOLID.
- DRY часто нарушается в больших проектах, а обдуманный копипаст с
    последующим улучшением бывает крайне полезен.
- BDUF - не всегда получается все продумать наперед, а дедлайны не дадут
    размышлять над этим вечно.
- YAGNI, APO, Оккама - в реальности хватает ситуаций, когда придется
    идти поперек и делать раньше, чем нужно - а именно сразу,
    непосредственно в течение текущей разработки, а не в последующем в
    ходе улучшений кода; с продумыванием наперед прямо в процессе, а не
    заранее.

Поэтому не стоит бояться их нарушить, это нормально и крайне часто имеет
место быть, но делать это надо обдуманно. Кроме, пожалуй, SOLID, который
в крупных проектах нарушать крайне нежелательно.
________________________________________________________________________

### SOLID ###

SOLID - не столько принцип проектирования программ, сколько их набор.
Содержит в себе 5 принципов (по одному на букву):

- **S**: Single Responsibility Principle (Принцип единственной
    ответственности).
- **O**: Open-Closed Principle (Принцип открытости-закрытости).
- **L**: Liskov Substitution Principle (Принцип подстановки Барбары
    Лисков).
- **I**: Interface Segregation Principle (Принцип разделения
    интерфейса).
- **D**: Dependency Inversion Principle (Принцип инверсии зависимостей).

Разберем каждый из них в отдельности.
________________________________________________________________________

***Принцип единственной ответственности*** (Single Responsibility
Principle, SRP) - каждая программная сущность (ф-ция, класс, модуль и
т.п.) должна быть ответственна за что-то одно. Иначе возникнут проблемы
как при чтении кода, так и при поддержке.

> **ПРИМЕР:** Допустим, мы разрабатываем простенькую RPG игру. Персонаж
игрока может прокачиваться, иметь различную экипировку, перемещаться,
бить врагов и наносить им урон.

- Плохая практика по SRP: дать классу игрока сразу и функционал
    перемещения/атаки/прокачки, и обработки нанесенного урона врагам, и
    сохранение новых статов и экипировки в к-л постоянном хранилище,
    например, БД. Все это разные задачи.

- Хорошая практика по SRP: оставить классу игрока вещи, нужные сугубо
    под задачи класса игрока: здоровье, управление, характеристики,
    слоты экипировки (хотя поседнее иногда имеет смысл вынести в
    отдельный класс, в зав-ти от сложности механик игры). Описание
    отдельных частей экипировки - в отдельные классы этих эл-тов.
    Обработка урона противникам - в класс противников. А сохранение
    данных - в отдельный класс менеджера сохранений или менеджера БД.
________________________________________________________________________

***Принцип открытости-закрытости*** (Open-Closed Principle, OCP) -
программные сущности должны быть открыты для расширения, но не для
модификации. Т.е. надо писать сущности так, чтобы их можно было
расширить новым функционалом в случае необх-ти, не меняя старый
функционал, только через добавление новых компонентов.

На практике OCP реализуется через наследование, интерфейсы, абстракции и
полиморфизм. Вместо изменения существующего кода добавляются новые
классы и функции.

> **ПРИМЕР:** В нашей игре есть разные мечи и топоры.

- Плохая практика по OCP: обрабатывать урон и накладываемые эффекты от
    каждого меча в коде метода "атаковать" игрока (что-то вроде "если
    экипирован обычный меч, то урон = 10, эффектов ноль; а если...").
    Мало того, что это нарушает и принцип SRP, так еще и при каждом
    добавлении нового меча или топора придется расширять этот список
    случаев, а читать и поддерживать такой код будет все сложнее и
    сложнее, особенно при балансе хар-к оружия.

- Хорошая практика по OCP: создать классы "Меч" и "Топор" с принимаемой
    хар-кой "урон" (для описания разных мечей и топоров одним
    соответствующим классом и по необх-ти - наследоваться от них для
    особых случаев и накладывания статусов на противника). После этого в
    соответствии с полиморфизмом ООП добавить метод или свойство в эти
    классы, возвращающее единообразно все необходимое для атаки, а из
    метода "атаковать" игрока вызывать этот метод или свойство. Тогда
    вне зав-ти от кол-ва оружий метод "атаковать" игрока не будет
    меняться, а функционал оружий будет лежать в определенном месте,
    упрощая поддержку и читаемость.
________________________________________________________________________

***Принцип подстановки Барбары Лисков*** (Liskov Substitution Principle,
LSP) - объекты в программе должны быть заменяемы их наследниками без
изменения корректности программы. Подкласс не должен нарушать ожидаемое
поведение программы. По сути в этом принципе раскрывается одна из сторон
полиморфизма.

> **ПРИМЕР:** Пусть у нас в игре есть разные мечи. Базовый меч дает
возм-ть производить только обычную атаку. У него есть модифицированные
версии: у зачарованного меча помимо обычной атаки есть специальная атака
с наложением на противника эффекта "горение", а у острого меча есть
только обычная атака, но она накладывает эффект "кровотечение". Классы
этих мечей наследуются от обычного меча.

- Плохая практика по LSP: ввести новый метод для обычной атаки,
    проигнорировав старый (что приведет к тому, что, наример, при замене
    обычного меча на острый игрок продолжит неожиданно быть без
    наложения статуса "кровотечение", обращаясь к старому интерфейсу),
    удалить старый метод обычной атаки (что, ожидаемо, приведет к ошибке
    при замене) или переписать метод обычной атаки там, где не надо
    (например, в зачарованном мече тогда обычная атака превратится во
    что-то иное, что не соответствует ТЗ). Кроме того, при появлении
    нового оружия, у которого и вовсе не должно быть функции обычной
    атаки, будет плохим решением наследовать класс такого оружия от
    класса базового меча, по аналогии с удалением метода или
    игнорированием его существования.

- Хорошая практика по LSP: у зачарованного меча не трогать метод обычной
    атаки, создать новый метод для "поджигающего" удара; у острого меча
    переписать метод обычной атаки с наложением статуса, не создавать
    новых методов. Если появляется новое оружие без обычной атаки -
    создать новый базовый класс, а не наследоваться от базового меча.
________________________________________________________________________

***Принцип разделения интерфейса*** (Interface Segregation Principle,
ISP) - классы программы не должны зависеть от тех методов, которые он не
используют. Создавайте узкоспециализированные интерфейсы. Вместо одного
большого интерфейса лучше создавать несколько маленьких — каждый со
своей задачей. За счёт такого подхода классы могут реализовывать только
те методы, что действительно нужны для их работы.

> **ПРИМЕР:** Пусть в нашей игре есть мечи и пистолеты.

- Плохая практика по ISP: создать класс Weapon, который будет содержать
    в себе атрибуты "урон", "кол-во патронов" и методы "атаковать" и
    "перезарядка". Для пистолетов такой набор хорош, и он реализует все,
    но для мечей параметр "кол-во патронов" и метод "перезарядка" не
    нужны и будут болтаться без дела.

- Хорошая практика по ISP: создать класс Weapon, содержащий атрибут
    "урон" и метод "атаковать". От него унаследовать класс мечей без
    изменений и класс пистолетов, добавив в последний атрибут "кол-во
    патронов" и метод "перезарядка".
________________________________________________________________________

***Принцип инверсии зависимостей*** (Dependency Inversion Principle,
DIP) - компоненты верхнего уровня не должны зависеть от компонентов
нижнего уровня. Иными словами, абстракции не должны зависеть от деталей.
Детали должны зависеть от абстракций.

> **ПРИМЕР:** В нашей игре есть мечи. Планируется в будущем добавить
    молоты. Кроме того, локальное сохранение ведется сейчас на базе
    PostgreSQL, но тестировка показала, что у целевой аудитории могут
    быть проблемы с ним. Несмотря на то, что PostgreSQL
    предпочтительнее, для аудитории с проблемами с ним хочется добавить
    автоматическую смену на SQLite.

- Плохая практика по DIP: в классе игрока жестко задать экземпляр класса
    "Меч" в экипировку, менять только характеристики при смене меча.
    Тогда при введении молотов придется тяжко, да и без более высокого
    уровня абстракции это не реализуемо без костылей. Аналогично и с
    выбором реализации SQL - если оставить жесткую привязку к методам
    работы с PostgreSQL, введение переключения на SQLite станет той еще
    проблемой.

- Хорошая практика по DIP: абстракция "Оружие", от него наследовать
    "Меч", класс игрока взаимодействует с методами абстракции "Оружие".
    Молот тогда введется как наследник "Оружия". Для БД - ввести
    абстракцию "Менеджер БД", а от него наследовать конкретные
    реализации.
________________________________________________________________________

Можно заметить, что принципы SOLID тесно связаны как между собой, так и
с другими принципами (ООП, KISS, YAGNI и т.д.), что нарушение одного
ведет к нарушению другого или даже нескольких других. Т.о. SOLID
частично дополняет, частично вбирает в себя и другие принципы и идет с
ними неразрывно.

С другой стороны, в некоторых местах он может конфликтовать с другими
принципами, напирая на будущие наработки или нарочито более сложное
исполнение. И хотя такое имеет место быть, SOLID считается более важной
практикой в крупных проектах, от которой лучше не отходить.

Тем не менее, все ситуативно, принципы не абсолютно конкретны, носят
рекомендательный характер, а конфликтующие с ними практики не являются
табу и могут иметь место быть в тех или иных задачах.
________________________________________________________________________

# ПАТТЕРНЫ #

...
________________________________________________________________________

# ИСТОЧНИКИ И ДОП. МАТЕРИАЛЫ #

1. [Сайт] **Статья по ООП от Яндекс Практикума**:
    [ссылка](https://practicum.yandex.ru/blog/obektno-orientirovannoe-programmirovanie/).
1. [Сайт] **Статья по KISS, DRY, YAGNI, SOLID и т.д. на Хабре**:
    [ссылка](https://habr.com/ru/companies/itelma/articles/546372/).
1. [Сайт] **Статьи о SOLID**:
    [ссылка](https://habr.com/ru/companies/ruvds/articles/426413/),
    [ссылка](https://blog.skillbox.by/kod/principy-solid-v-oop-chto-jeto-i-kak-ih-primenjat-skillbox-media/),
    [ссылка](https://timeweb.cloud/blog/solid-principy-i-ih-rol-v-razrabotke-po).
1. [Литература] **Э. Гамма, Р. Хелм, Р. Джонсон, Дж. Влиссидес ("Банда**
    **Четырех") - Паттерны ООП**.
1. [Сайт] **Шпаргалки по паттернам проектирования**:
    [ссылка](http://refactoringu.ru/ru/design-patterns/catalog.html),
    [ссылка](https://bool.dev/blog/detail/gof-design-patterns).
________________________________________________________________________
