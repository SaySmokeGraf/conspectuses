________________________________________________________________________

# СОДЕРЖАНИЕ #

- > **[СТАНДАРТНЫЕ](#стандартные)**
    1. > **[abc](#abc)**
    1. > **[asyncio](#asyncio)**
    1. > **[atexit](#atexit)**
    1. > **[bisect](#bisect)**
    1. > **[cmath](#cmath)**
    1. > **[collections](#collections)**
    1. > **[contextlib](#contextlib)**
    1. > **[copy](#copy)**
    1. > **[csv](#csv)**
    1. > **[ctypes](#ctypes)**
    1. > **[dataclasses](#dataclasses)**
    1. > **[datetime](#datetime)**
    1. > **[dateutil](#dateutil)**
    1. > **[functools](#functools)**
    1. > **[glob](#glob)**
    1. > **[hashlib](#hashlib)**
    1. > **[heapq](#heapq)**
    1. > **[importlib](#importlib)**
    1. > **[itertools](#itertools)**
    1. > **[json](#json)**
    1. > **[logging](#logging)**
    1. > **[math (+cmath)](#math-cmath)**
    1. > **[multiprocessing](#multiprocessing)**
    1. > **[operator](#operator)**
    1. > **[os](#os)**
    1. > **[pathlib](#pathlib)**
    1. > **[pickle](#pickle)**
    1. > **[queue](#queue)**
    1. > **[re](#re)**
    1. > **[shelve](#shelve)**
    1. > **[shutil](#shutil)**
    1. > **[socket](#socket)**
    1. > **[sqlite3](#sqlite3)**
    1. > **[string](#string)**
    1. > **[struct](#struct)**
    1. > **[sys](#sys)**
    1. > **[threading](#threading)**
    1. > **[time](#time)**
    1. > **[timeit](#timeit)**
    1. > **[typing](#typing)**
    1. > **[venv](#venv)**
    1. > **[zlib](#zlib)**
- > **[ВНЕШНИЕ](#внешние)**
    1. > **[flake8](#flake8)**
    1. > **[matplotlib](#matplotlib)**
    1. > **[numba](#numba)**
    1. > **[numpy](#numpy)**
    1. > **[pandas](#pandas)**
    1. > **[psycopg2](#psycopg2)**
    1. > **[pygame](#pygame)**
    1. > **[PyQt](#pyqt)**
    1. > **[PySide](#pyside)**
    1. > **[requests](#requests)**
    1. > **[scipy](#scipy)**
    1. > **[sqlalchemy](#sqlalchemy)**
- > **[МАТЕРИАЛЫ](#материалы)**
________________________________________________________________________

# СТАНДАРТНЫЕ #

### abc ###

abc - от Abscract Base Classes - модуль с абстрактными базовыми
классами (АБК). АБК позволяют определить класс, указав при этом, какие
методы или свойства обязательно переопределить в классах-наследниках.

Пример:

```python
from abc import ABCMeta, abstractmethod, abstractproperty

class Movable():
    __metaclass__=ABCMeta

    @abstractmethod
    def move():
    """Переместить объект"""
    
    @abstractproperty
    def speed():
    """Скорость объекта"""
```
________________________________________________________________________

Что почитать:

**Абстрактные классы и интерфейсы в Питоне**:
[ссылка](https://habr.com/ru/articles/72757/).

**Абстрактные классы и методы**:
[ссылка](https://metanit.com/python/tutorial/7.8.php).

**Документация abc**:
[ссылка](https://docs.python.org/3/library/abc.html).
________________________________________________________________________

### asyncio ###

Отвечает за асинхронное программирование в Python.

*Синхронное программирование* - это классическое программирование, где
операции производятся подряд поочередно. Пока не исполнится текущая
операция и не вернет ответ, не начнет выполняться следующая.

*Асинхронное программирование* - это вид параллельного программирования,
в котором какая-либо единица работы может выполняться отдельно от
основного потока выполнения приложения. Команда выполнить операцию
отправляется, но программа не ждет ответа, а переходит далее, и затем,
когда операция выполнится, в основной поток возвращается событие об
окончании операции, который можно отловить и работать с результатами.

Это отдельная тема в программировании, в том числе на Python, и притом
из продвинутого уровня, поэтому просто оставлю ссылки на почитать, при
необходимости - изучить подробнее.
________________________________________________________________________

**Подробнее**:

- [ссылка](https://habr.com/ru/companies/otus/articles/509328/).
- [ссылка](https://python-academy.org/ru/guide/asyncio-basics).
- [ссылка](https://habr.com/ru/articles/667630/).
________________________________________________________________________

### atexit ###

Определяет ф-ции для регистрации и отмены регистрации ф-ций очистки (или
ф-ций для выполнения по выходу из программы). Зарегистрированные таким
образом ф-ции автоматически выполняются после обычного завершения
интерпретатора. Выполняет в обратном порядке регистрации.

- `atexit.register(func, *args, **kwargs)` - зарегистрировать ф-цию.
    Можно использовать как декоратор.
- `atexit.unregister(func, *args, **kwargs)` - отменить регистрацию
    ф-ции. Ничего не делает, если ф-ция не была зарегистрирована.

Примеры см. в документации.
________________________________________________________________________

**Документация**:
[ссылка](https://docs.python.org/3/library/atexit.html).
________________________________________________________________________

### bisect ###

Модуль с ф-циями для метода бисекции (бинарный поиск) в отсортированном
списке.

- `bisect_left(a, x, lo=0, hi=len(a), *, key=None)` - поиск позиции в
    списке a, первое вхождении больше или равное x. lo, hi - для
    выделения подмножества, key - для ф-ции.
- `bisect_right(a, x, lo=0, hi=len(a), *, key=None)` - строго больше
    значения x.
- `bisect` - то же, что и `bisect_right`.
- `insort_left(a, x, lo=0, hi=len(a), *, key=None)` - bisect_left +
    вставка по индексу.
- `insort_right`, `insort` - bisect_right + вставка по индексу.
________________________________________________________________________

Ф-ции и примеры ф-ций на основе модуля bisect:

1. Поиск в отсортированных списках:

```python
def index(a, x):
    'Находит крайнее левое значение, точно равное x'
    i = bisect_left(a, x)
    if i != len(a) and a[i] == x:
        return i
    raise ValueError

def find_lt(a, x):
    'Находит крайнее правое значение меньшее, чем x'
    i = bisect_left(a, x)
    if i:
        return a[i-1]
    raise ValueError

def find_le(a, x):
    'Находит крайнее правое значение меньше или равно x'
    i = bisect_right(a, x)
    if i:
        return a[i-1]
    raise ValueError

def find_gt(a, x):
    'Находит крайнее левое значение больше, чем x'
    i = bisect_right(a, x)
    if i != len(a):
        return a[i]
    raise ValueError

def find_ge(a, x):
    'Находит крайний левый элемент больше или равен x'
    i = bisect_left(a, x)
    if i != len(a):
        return a[i]
    raise ValueError
```

2. Бинарный поиск:

```python
def binary_search(a, x, lo=0, hi=None):
    if hi is None:
        hi = len(a)
    # поиск индекса `x`
    pos = bisect_left(a, x, lo, hi)
    # проверка и возврат результата
    return pos if pos != hi and a[pos] == x else -1
```

3. Преобразование интервалов в значения:

```python
def grade(score, breakpoints=[60, 70, 80, 90], grades='FDCBA'):
    i = bisect(breakpoints, score)
    return grades[i]
```

4. Поиск слова по префиксу:

```python
def prefix_search(wordlist, prefix):
    try:
        # находим индекс слова в списке `wordlist`, 
        # содержащие `prefix`
        index = bisect_left(wordlist, prefix)
        # возвращаем слово
        return wordlist[index]
    except IndexError:
        # или возвращаем False
        return False
```
________________________________________________________________________

### cmath ###

См. раздел [math (+cmath)](#math-cmath).
________________________________________________________________________

### collections ###

Содержит в себе дополнительные типы данных.
________________________________________________________________________

`Counter()` - счетчик. Принимает итерируемый объект с неизменяемыми
эл-тами, а возвращает словарь-подобный объект Counter, где ключи -
эл-ты принимаемого объекта, а значения - их кол-во в принимаемом
объекте. Можно пользоваться как словарем со значениями по умолчанию
(т.е. при обращении к ключу, которого нет, выдает не ошибку, а 0).

`list(<counter>.elements())` - преобразует счетчик в список (как бы
обратное преобразование).

`<counter>.most_common(<n>)` - возвращает список кортежей типа zip с n
самыми частыми эл-тами и их счетчиками. При неуказании n выводит все,
упорядоченное по убыванию включений.

Операнд `&` даст минимальные значения для одних и тех же подсчитываемых
эл-тов двух счетчиков, операнд `|` – максимальные.

`cnt1.subtract(cnt2)` - вычесть из cnt1 cnt2, результат в cnt1.

`+cnt`, `-cnt` - возвращают положительные и отрицательные значения
сооветственно.

`cnt.clear()` - очистить счетчик.

Используется с модулем `re` для частотного анализа текста. Пример с
сайта по поиску 10 самых частых слов в "Евгении Онегине".

```python
...
words = re.findall(r'\w+', open('onegin.txt').read().lower())
cnt = collections.Counter(words).most_common(10)
...
```
________________________________________________________________________

`defaultdict()` - словарь со значениями по умолчанию. В качестве
параметра передается тип данных, дефолтное значение которого и будет
устанавливаться при попытке обращения по несуществующему ключу. Не
выдает ошибки в таком случае.

У обычного словаря есть метод `setdefault()`, но такое исполнение менее
наглядно и более медленное.

Помимо str и int, defaultdict часто используют в связке с пустым
списком, чтобы начинать добавление элементов без лишнего кода. Пример:

```python
>>> dict_of_lists = collections.defaultdict(list)
>>> for i in range(5):
...     dict_of_lists[i].append(i)
... 
>>> dict_of_lists
defaultdict(<class 'list'>, {0: [0], 1: [1], 2: [2], 3: [3], 4: [4]})
```
________________________________________________________________________

`OrderedDict()` - упорядоченный словарь. С Python 3.6 и обычный dict
запоминает порядок вставки, но тем не менее все же обычный dict
предназначен для быстрого мапирования, в то время как переупорядочивание
страдает. Т.о. OrderedDict будет лучше, где надо чаще переупорядочивать.

`<orddict>.popitem(last=True)` – удаляет последний элемент если
`last=True` (дефолт), и первый, если `last=False`.

`<orddict>.move_to_end(key, last=True)` – переносит ключ key в конец,
если `last=True` (дефолт), и в начало, если `last=False`.
________________________________________________________________________

`ChainMap()` - контейнер словарей - надструктура над словарями, в
которую можно их объединить. При этом получается не один общий словарь,
а их совокупность, в которой каждый словарь остаётся независимой
составляющей.

При обращении к ChainMap по ключу одного из словарей, происходит поиск
значения среди всех словарей, при этом нет необходимости указывать
конкретный словарь; выводит первое найденное значение (проходя словари
по очереди добавления).

Изменение содержания словаря изменяет и ChainMap. Нет необходимости
перезаписывать надструктуру. Как бы некоторое подобие view.

`<chain>.new_child(<new_child>)` - добавить в контейнер новый словарь.
Создает новую структуру, а не обновляет старую.
________________________________________________________________________

`deque()` - "дэк", двусвязная очередь. Является усовершенствованным
вариантом списка с оптимизированной вставкой/удалением элементов с обоих
концов. Реализация deque оптимизирована так, что операции слева и справа
имеют примерно одинаковую сложность O(1). Добавление новых элементов в
конец происходит не сильно медленнее, чем во встроенных списках, но
добавление в начало выполняется существенно быстрее.

У методов `append`, `extend` и `pop` есть аналоги `appendleft`,
`extendleft` и `popleft`.

`<deq>.rotate(n=1)` – последовательно переносит n элементов из начала в
конец (если n отрицательно, то с конца в начало). В этом поведение deque
напоминает кольцевой связный список.
________________________________________________________________________

`namedtuple()` – функция-фабрика для создания именованных кортежей. Этот
тип данных похож на struct в других языках программирования. Возвращает
класс, и исходя из этого можно использовать его и по назначению, и как
объект для наследования, и т.д.

Пример использования:

```python
>>> cols = ['fname', 'pname', 'lname', 'age']
>>> User = collections.namedtuple('User', cols)
>>> user1 = User('Петр', 'Иванович', 'Сидоров', 30)
>>> user1
User(fname='Петр', pname='Иванович', lname='Сидоров', age=30)
>>> user1.lname
Сидоров
>>> Point = collections.namedtuple('Point', ['x', 'y'])
>>> p = Point(3, 4)
>>> p.x**2 + p.y**2
25
```

Именованные кортежи делают код яснее. Остаётся доступной и численная
индексация.

Именованные кортежи часто используются для назначения имён полей
кортежам, возвращаемым модулями csv или sqlite3:

```python
EmployeeRecord = collections.namedtuple('EmployeeRecord',
                            'name, age, title, department, paygrade')

import csv
for emp in map(EmployeeRecord._make, csv.reader(open("employees.csv", "rb"))):
    print(emp.name, emp.title)

import sqlite3
conn = sqlite3.connect('/companydata')
cursor = conn.cursor()
cursor.execute('SELECT name, age, title, department, paygrade FROM employees')
for emp in map(EmployeeRecord._make, cursor.fetchall()):
    print(emp.name, emp.title)
```

`ntuple._asdict()` - возвращает dict из namedtuple.

`ntuple._fields` - константа с кортежем имен полей ntuple.

Чтобы преобразовать словарь в именованный кортеж заданного типа,
достаточно распаковать его оператором **:

```python
>>> d = {'x': 0, 'y': 1}
>>> Point(**d)
Point(x=0, y=1)
```
________________________________________________________________________

`UserDict`, `UserList`, `UserString` - обертки над стандартными
объектами словарей, списков и строк для беспроблемного наследования
(прямое наследование встроенным типам dict, list, str чревато ошибками,
связанными с игнорированием переопределения методов).
________________________________________________________________________

### contextlib ###

Предназначен для создания контекстных менеджеров и работы с `with`.

Есть ряд встроенных контекстных менеджеров, которые могут оказаться
полезны:

- `closing` - закроет объект по завершению работы с ним. Может
    понадобиться при отсутствии возм-тей контекстного менеджера на ф-ции
    инициализации подключения, что в текущих реалиях - редкость.
- `suppress` - для подавления исключений.
- `redirect_stdout`, `redirect_stderr` - перенаправить stdout или stderr
    соответственно.
- `ExitStack` - для комбинирования контекстных менеджеров.
________________________________________________________________________

**Подробнее**:
[ссылка](https://python-scripts.com/contextlib).
________________________________________________________________________

### copy ###

Предназначен для поверхностного и глубокого копирования. В общем-то,
поверхностное копирование есть и в методах стандартных структур данных
Python, но для глубокого копирования модуль нужен.

`deepcopy(<smth>)` - возвращает глубокую копию smth, что позволяет
избежать при изменении оригинального объекта изменений в копии при
поверхностном копировании объекта, имеющего в своем составе изменяемый
объект наподобие списка.
________________________________________________________________________

### csv ###

Для работы с csv файлами.

**Более подробно**:
[ссылка](https://all-python.ru/osnovy/csv.html).
________________________________________________________________________

### ctypes ###

Python библиотека внешних функций. Она предоставляет C-совместимые типы
данных и позволяет вызывать функции из DLL или разделяемых библиотек. Ее
можно использовать для оборачивания этих библиотек в чистый Python.

**Документация**:
[ссылка](https://docs.python.org/3/library/ctypes.html).

**Статья Хабр**:
[ссылка](https://habr.com/ru/articles/466499/).

**Гайд python-scripts**:
[ссылка](https://python-scripts.com/extending-python-with-c-libraries).
________________________________________________________________________

### dataclasses ###

Предназначен для создания классов данных. Вместо:

```python
class Book:
    def __init__(self, title: str, author: str, desc: str):
        self.title = title
        self.author = author
        self.desc = desc
```

Можно сделать:

```python
from dataclasses import dataclass

@dataclass
class Book:
    title: str
    author: str
    desc: str
```

Важно отметить, что аннотации типов обязательны. Все поля, которые не 
имеют отметок о типе, будут проигнорированы. Конечно, если надо не
использовать конкретный тип, можно указать Any.

Можно указывать значения по умолчанию. 

Так код нагляднее, читабельнее, проще и быстрее пишется. Кроме того,
автоматически получается класс с реализованными методами `__init__`,
`__repr__`, `__str__` и `__eq__`. Более того, это будет обычный класс,
от которого можно наследоваться или добавлять производльные методы.

Из альтернатив - namedtuple, но он менее гибок за счет своей
неизменяемости. Кроме того, у `dataclass` есть ряд параметров. Например,
`frozen=True` сделает его неизменяемым. По аналогии можно
включать/выключать создание методов `__init__`, `__repr__`, `__eq__` и
набора методов `__gt__`, `__ge__`, `__lt__`, `__le__` с помощью пар-ров
`init`, `repr`, `eq` и `order` соответственно.

`<Class> = make_dataclass(name, [namecol1, ..., namecoln])` - ф-ция для
создания класса данных.

Для задания изменяемоего объекта как значения по умолчанию надо
использовать ф-цию `field`. Например:
`books: List[Book] = field(default_factory=list)`.

Важно помнить и об определении метода `__post_init__`, который
выполняется после `__init__`. В данном случае из-за особенностей классов
данных использование пост-инита - единственный способ обработки данных
по необходимости, если нужно. В остальном такие классы ведут себя как
обычно.
________________________________________________________________________

### datetime ###

Модуль даты и времени. Содержит в себе подмодули:

- time
- date
- datetime
- timedelta

Т.е. позволяет работать с временем и датой или отдельно с временем или
датой, что более широкий функционал, чем у модуля time. Кроме того,
позволяет находить разницу между соответствующими объектами, создавая
объект timedelta.

Стандартный формат: `YYYY-mm-dd HH:MM:SS.mcSmcS`.
________________________________________________________________________

По datetime:

- `datetime.datetime.now()` - текущее дата-время.
- `datetime.datetime(Y, m, d, H, M, S, mcS)` - создать свой объект
    класса datetime.
________________________________________________________________________

По date:

- `datetime.date.today()` - текущая дата.
- `datetime.date(Y, m, d)` - своя дата.
________________________________________________________________________

По time:

- Получение текущего времени только через объект datetime:
    `<var> = datetime.datetime.now()`, а затем `<var>.time()`.
- `datetime.time(H, M, S, mcS)` - свой объект класса time.
________________________________________________________________________

По timedelta:

- При разнице любых двух экземпляров одного из классов создается объект
    timedelta, отвечающий на вопрос о разнице между двумя датами или
    дата-временами. С временем (т.е. с time) разница не работает.
- Можно создать такой объект отдельно и прибавлять его к датам или
    дата-временам или вычитать для получения будущих или прошлых дат.
________________________________________________________________________

В целом:

- Даты, времена и даты-времена можно сравнивать для понимания, что было
    раньше или позже.
- В datetime нельзя в чистом виде работать с часовыми поясами. Для
    работы с часовыми поясами придется использовать другой модуль,
    например, pytz - Python Time Zones. Полученный часовой пояс можно
    использовать в методах класса datetime.
- `datetime.strptime(date_string, format)` - получить из строки объект
    даты-времени. Формат задается строкой с кодовыми символами. Таблицу
    таковых можно посмотреть в интернете.
- `datetime_object.strftime(format_string)` - операция, обратная
    предыдущей.

Рекомендации:

- Рекомендуется всегда работать с UTC. Это позволяет не думать о часовых
    поясах, что часто приводит к ошибкам из-за разницы во времени в
    разных регионах.
- Дату и время стоит конвертировать в локальную только при выводе
    пользователю.
________________________________________________________________________

**Документация**:
[ссылка](https://docs.python.org/3/library/datetime.html).

**Модуль datetime в Python**:
[ссылка](https://pythonru.com/primery/kak-ispolzovat-modul-datetime-v-python).

**Нахождение длительности временных интервалов**:
[ссылка](https://habr.com/ru/companies/ruvds/articles/648237/).
________________________________________________________________________

### dateutil ###

Модуль для парсинга дат и времени разных форматов из строк. Ему не нужны
регулярные выражения при определении формата, как для datetime.strptime.
Парсер ищет узнаваемые токены и либо возвращает корректный результат,
либо выдает ошибку.

**Модуль datetime в Python**:
[ссылка](https://pythonru.com/primery/kak-ispolzovat-modul-datetime-v-python).
________________________________________________________________________

### functools ###

Библиотека, созданная для упрощения работы с функциями. Имеет решения
для разнообразных ситуаций, которые иначе решались бы часто неприятным
кодом.
________________________________________________________________________

Простой и мощный функционал - кэширование, а именно ф-ции (декотраторы)
`lru_cache`, `cache` и `cached_property`.

Первый - `lru_cache` - сохраняет LRU кэш результатов выполнения ф-ции и
подгружает результаты при тех же входных данных, если они есть в LRU.
Задается размером maxsize, имеет ряд методов и свойств.

`cache` - упрощенная версия предыдущего, без удаления и maxsize.

`cached_property` - используется для кэширования результатов расчетов
атрибутов класса. Механика очень полезная, если у вас есть свойство,
которое дорого вычислять, но оно при этом остается неизменным. Еще одна
прелесть `cached_property` в том, что он запускается только при поиске,
поэтому позволяет нам менять значение атрибута. После изменения атрибута
закэшированное ранее значение меняться не будет, вместо этого будет
вычислено и закэшировано новое значение.

> **НО!** Не следует использовать их, если у ф-ции есть какие-то
побочные эффекты или если она при каждом вызове создает изменяемые
объекты, поскольку это явно не те функции, которые следует кэшировать.
________________________________________________________________________

Наиболее используемая лично мной ф-ция-декоратор `wraps`. Решает одну
проблему с декораторами, а именно тот факт, что задекорированные ф-ции
в итоге получают имя и документацию ф-ции, возвращаемой декоратором.

Для пояснения пример:

```python
def decorator(func):
    def actual_func(*args, **kwargs):
        """Inner function within decorator, which does the actual work"""
        print(f"Before Calling {func.__name__}")
        func(*args, **kwargs)
        print(f"After Calling {func.__name__}")

    return actual_func

@decorator
def greet(name):
    """Says hello to somebody"""
    print(f"Hello, {name}!")

print(greet.__name__)
print(greet.__doc__)
```

Этот код выведет:

```
actual_func
Inner function within decorator, which does the actual work
```

Видно, что, запросив имя и документацию ф-ции greet, мы получили не ее
имя и документацию.

Теперь используем wraps:

```python
from functools import wraps

def decorator(func):
    @wraps(func)
    def actual_func(*args, **kwargs):
        """Inner function within decorator, which does the actual work"""
        print(f"Before Calling {func.__name__}")
        func(*args, **kwargs)
        print(f"After Calling {func.__name__}")

    return actual_func

@decorator
def greet(name):
    """Says hello to somebody"""
    print(f"Hello, {name}!")

print(greet.__name__)
print(greet.__doc__)
```

Этот код выведет:

```
greet
Says hello to somebody
```

Как и должно быть.
________________________________________________________________________

Можно использовать `partial` для "замораживания" некоторых (или всех)
аргументов функции, создавая новый объект с упрощенной сигнатурой
функции.

Простой пример:

```python
import sys
from functools import partial

print_stderr = partial(print, file=sys.stderr)
print_stderr("This goes to standard error output")
```

Позволяет создать т.о. ф-цию print_stderr, которая записывает сообщения
в stderr вместо stdout. При частом использовании позволяет не
дублировать постоянную передачу направления записи для print, а просто
использовать модифицированный partial объект.

В данном примере заменяется всего 1 аргумент, но таких может быть
множество. Чем больше требуется "заморозить" аргументов, тем полезнее
partial выглядит.
________________________________________________________________________

Декоратор `total_ordering` для класса позволяет вместо задавания всех
волшебных методов сравнения `__eq__`, `__lt__`, `__le__` и т.п. задать
всего 2 - `__eq__` и любой из `__lt__`, `__gt__`, а остальное декоратор
добавит сам.
________________________________________________________________________

`reduce` - берет итерируемый объект и сворачивает (складывает) все его
значения в одно.

Например:

```python
from functools import reduce
import operator

def product(iterable):
    return reduce(operator.mul, iterable, 1)

def factorial(n):
    return reduce(operator.add, range(1, n))

print(product([1, 2, 3]))
# 6
print(factorial(5))
# 24
```
________________________________________________________________________

Можно реализовать перегрузку ф-ций для паттернов с помощью
`singledispatch` и `singledispatchmethod`.
________________________________________________________________________

**Документация**:
[ссылка](https://docs.python.org/3/library/functools.html).

**О functools в статье на Хабре**:
[ссылка](https://habr.com/ru/companies/otus/articles/573164/).
________________________________________________________________________

### glob ###

Для поиска всех путей по шаблону. Исп-ся с os, shutil и т.п.

**Подробнее**:
[ссылка](https://pythonworld.ru/moduli/modul-glob.html).
________________________________________________________________________

### hashlib ###

Предоставляет набор функций для работы с криптографическими
хеш-функциями, такими как MD5, SHA-1, SHA-256 и другими.

**Подробнее**:
[ссылка](https://sky.pro/media/kak-rabotat-s-modulem-hashlib-v-python/).
________________________________________________________________________

### heapq ###

Heap Queue DS - структура данных "приоритетная очередь", или куча. В
данном модуле имеется функционал для создания онной на списке. По своей
сути новой структуры данных не предоставляет, переставляя все "на месте"
в передаваемом списке. Кроме того, в heapq реализована куча минимумов и
только она.

Имеются ф-ции:

- `heapq.heapify(x)` - переместить эл-ты x относительно друг друга "на
    месте" так, чтобы x стало кучей.

- `heapq.heappush(heap, item)`, `heapq.heappop(heap)` - push и pop
    соответственно.

- `heapq.heappushpop(heap, item)` - сначала push, а затем pop. За счет
    реализации быстрее пораздельного использования.

- `heapq.heapreplace(heap, item)` - сначала pop, а затем push. За счет
    реализации быстрее пораздельного использования.

- `heapq.nsmallest(n, iterable, key=None)`,
    `heapq.nlargest(n, iterable, key=None)` - найти с помощью
    пирамидальной сортировки n наименьших или наибольших эл-тов
    итерируемого объекта.

- `heapq.merge(*iterables, key=None, reverse=False)` - слить несколько
    отсортированных по возрастанию итерируемых объектов.
________________________________________________________________________

### importlib ###

Для динамического и расширенного функционала импортирования.

**Более подробно**:
[ссылка](https://python-scripts.com/importlib).
________________________________________________________________________

### itertools ###

Предоставляет набор различных итераторов и генераторов.
________________________________________________________________________

Бесконечные итераторы:

- `count([start, step])` - счетчик, начинающийся с start (по умолчанию
    равен 0), с шагом step (по умолчанию - 1). Добавляется ф-цией
    `next(<cntr>)`, кторая возвращает следующий эл-т.

    Часто используется с zip и map.

    `zip(count(), <list>)` - пример с zip.

    `map(lambda x: x**2, count())` - пример с map (возвращает
    бесконечный map-итератор с квадратами).

- `cycle(iterable)` - cоздает итератор, возвращающий элементы из
    итерируемого объекта и сохраняющий копию каждого из них. Когда
    итерируемый объект заканчивается, возвращается элемент из
    сохраненной копии. Работает бесконечно.

    `next(<cycle>)` - следующий эл-т.

- `repeat(object[, times])` - повторить объект. Без указания times
    бесконечен, с указанием - конечен.

    Может исп-ся для map и zip.

    `zip(repeat(<smth>), <list>)` - пример с zip.

    `map(pow, range(10), repeat(2))` - пример с map (возвращает
    map-итератор с квадратами).

    `next(<repeater>)` - следующий эл-т.
________________________________________________________________________

Конечные итераторы:

- `accumulate(iterable, func, *, initial=None)` - создает итератор,
    который возвращает накопленную сумму или накопленный результат
    других бинарных функций, которые указаны в параметре func. Обычно
    кол-во эл-тов в выходной итерации совпадает с кол-вом эл-тов во
    входной итерации. Если указывается параметр initial, он также
    учитывается, поэтому выходная итерация содержит на один эл-т больше,
    чем входная.

    Например:
    `list(accumulate([1, 2, 3, 4, 5], operator.add, initial=10))`
    вернет `[10, 11, 13, 16, 20, 25]`, а
    `list(accumulate([2, 4, 6, 3, 1], max))` вернет `[2, 4, 6, 6, 6]`.

- `chain(*iterables)` - cоздает итератор, который возвращает эл-т из
    итерируемого объекта до тех пор, пока он не закончится, а потом
    переходит к следующему. Он будет рассматривать последовательности,
    идущие друг за другом, как одну.

- `chain.from_iterable(iterable)` - эта функция берет один итерируемый
    объект в качестве входного аргумента и возвращает «склеенный»
    итерируемый объект, содержащий все эл-ты входного. Все эл-ты,
    подаваемые на вход, должны быть итерируемыми, иначе выпадет
    исключение TypeError.

- `compress(data, selectors)` - создает итератор, который фильтрует
    эл-ты data, возвращая только те, которые содержат соответствующий
    эл-т в селекторах (selectors), стоящих в True. Прекращает
    выполнение, когда либо данные, либо селекторы закончились.

    Например: `compress([1, 2, 3, 4], [True, False, False, True])`
    вернет `[1, 4]`.

- `dropwhile(predicate, iterable)`, а также `takewhile()` и
    `filterfalse()` нужны для создания итератора, отфильтрованного по
    предикату.

- `zip_longest(*iterables, fillvalue=None)` - zip, но прерывается по
    окончанию самого длинного итерируемого объекта, заполняя нехватающие
    эл-ты fillvalue.

- `starmap(function, iterable)` - map, но для сгруппированных в кортежи
    в одном итерируемом объекте параметров ф-ции.

- `islice(iterable, start, stop[, step])` - срез для итерируемого
    объекта.

- `tee(iterable, n=2)` - возвращает n независимых итераторов из одного
    итерируемого объекта.

- `groupby(iterable, key=None)` - создает итератор, который возвращает
    последовательно ключи и группы из итерируемого объекта.
________________________________________________________________________

Комбинаторные генераторы:

- `product(*iterables[, repeat])` - декартово произведение итерируемых
    объектов, подаваемых на вход.

    Пример: `list(product("ABC", [1, 2]))` вернет
    `[('A', 1), ('A', 2), ('B', 1), ('B', 2), ('C', 1), ('C', 2)]`, а
    `list(product("xy", repeat=2))` вернет
    `[('x', 'x'), ('x', 'y'), ('y', 'x'), ('y', 'y')]`.

- `permutations(iterable, r=None)` - возвращает последовательные
    перестановки наборов из r эл-тов в итерируемом объекте. Если
    параметр r не указан или стоит в значении None, то по умолчанию r
    принимает длину итерируемого объекта и генерирует полноценные
    перестановки. Эл-ты рассматриваются как уникальные в зависимости от
    их позиции, а не от их значения. Таким образом, если входные эл-ты
    уникальны, то в каждой перестановке не будет повторяющихся значений.

- `combinations(iterable, r)`,
    `combinations_with_replacement(iterable, r)` - возвращают комбинации
    длиной r из эл-тов итерируемого объекта. В первой без возм-ти
    использования одного и того же эл-та, во второй - с.
________________________________________________________________________

**Более подробно**:

- [ссылка](https://docs.python.org/3/library/itertools.html).
- [ссылка](https://habr.com/ru/companies/otus/articles/529356/).
- [ссылка](https://habr.com/ru/articles/132554/).
________________________________________________________________________

### json ###

Предназначен для работы с JSON объектами.

- `dumps`, `dump` - для преобразования объекта Python в JSON-строку и в
    json-файл соответственно.
- `loads`, `load` - обратное действие.

Для правильной работы необходимо учитывать особенности JSON и его
синтаксиса.
________________________________________________________________________

**Краткий гайд**:
[ссылка](https://practicum.yandex.ru/blog/modul-json-v-python/)/

**Документация**:
[ссылка](https://docs.python.org/3/library/json.html).
________________________________________________________________________

### logging ###

Для логирования.

**Более подробно**:
[ссылка](https://habr.com/ru/companies/wunderfund/articles/683880/).
________________________________________________________________________

### math (+cmath) ###

Модуль для работы с математическими ф-циями и константами. Модуль cmath
\- то же самое, но для комплексных чисел.
________________________________________________________________________

**Константы**:

- `pi`, `tau` - пи и тау (2 пи).
- `e` - экспонента.
- `inf`, `-inf` - бесконечности.
- `nan` - не число (not a number).

**Функции**:

Теория чисел:

- `factorial` - факториал.
- `lcm`, `gcd` - НОК и НОП.
- `comb`, `perm` - комбинация и пермутация.

Работа с числами с плавающей точкой:

- `floor`, `ceil` - округление вниз и вверх соответственно.
- `isinf`, `isnan`, `isfinite` - проверка на бесконечность, на NaN и на
    небесконечность и не NaN соответственно.
- `fmod` - остаток от деления дробных чисел.
- `fsum` - точная сумма.

Степени:

- `pow` - возведение в степень.
- `exp` - экспонента в степени.
- `sqrt`, `cbrt` - квадратный и кубический корень.
- `log`, `log2`, `log10` - логарифм по произвольному основанию,
    основаниям 2 и 10 соответственно.

Тригонометрия:

- `sin`, `cos`, `tan`, `asin`, `acos`, `atan` - тригонометрические
    ф-ции, работают с радианами.
- `sinh`, `cosh`, `tanh`, `asinh`, `acosh`, `atanh` - гиперболические
    ф-ции.
- `degrees`, `radians` - перевод из радианов в градусы и наоборот.

Спец. функции:

- `erf`, `erfc` - ф-ция ошибок и комплементарная ф-ция ошибок.
- `gamma`, `lgamma` - гамма-ф-ция и натуральный логарифм гамма-ф-ции.

Прочие:

- `dist` - евклидово расстояние между точками.
- `prod` - произведение.
________________________________________________________________________

**Документация**:
[ссылка](https://docs.python.org/3/library/math.html).
________________________________________________________________________

### multiprocessing ###

Библиотека для многопроцессности - истинного параллелизма без GIL с
одной стороны и использованием процессов вместо потоков с другой.
Последнее привносит трудности в обмен данными между параллельно
исполняемыми частями кода, так как каждый процесс работает в своем
изолированном пространстве памяти со своим интерпретатором и GIL.

Плюсы по сравнению с многопоточностью:

- Настоящий параллелизм. Позволяет многопроцессности выделяться для
    CPU-bound (интенсивные вычисления) задач.
- Изолированность позволяет снизить риски конфликтов.

Минусы:

- Процесс более ресурсоемок (что логично вследствие отдельных
    интерпретаторов на каждый процесс).
- Обмен данными между процессами сложнее и медленнее, что делает его
    менее подходящим для I/O-bound (ожидание инпута-аутпута) задач.

При необходимости - изучить больше.
________________________________________________________________________

**Документация**:
[ссылка](https://docs.python.org/3/library/multiprocessing.html).

**Краткие обучающие пояснения от Python Academy**:
[ссылка](https://python-academy.org/ru/guide/multiprocessing-module).
________________________________________________________________________

### operator ###

Для представления операторов в виде ф-ций. Полезно при передаче в
некоторые ф-ции и объекты параметра-ф-ции. Например, `functools.reduce`.
Кроме того, имеет ряд дополнительных ф-ций для работы с аргументами,
параметрами, св-вами.

**Документация**:
[ссылка](https://docs.python.org/3/library/operator.html).
________________________________________________________________________

### os ###

Модуль os предоставляет множество функций для работы с операционной
системой, причём их поведение, как правило, не зависит от ОС, поэтому
программы остаются переносимыми.
________________________________________________________________________

Некоторые переменные, константы и ф-ции в os:

- `os.name` - имя операционной системы. Доступные варианты: 'posix',
    'nt', 'mac', 'os2', 'ce', 'java'.

- `os.environ` - словарь переменных окружения. Изменяемый (можно
    добавлять и удалять переменные окружения).

- `os.getlogin()` - имя пользователя, вошедшего в терминал (Unix).

- `os.getpid()` - текущий id процесса.

- `os.uname()` - информация об ОС. Возвращает объект с атрибутами:
    sysname - имя операционной системы, nodename - имя машины в сети
    (определяется реализацией), release - релиз, version - версия,
    machine - идентификатор машины.

- `os.chdir(path)` - смена текущей директории.

- `os.getcwd()` - текущая рабочая директория.

- `os.link(src, dst, *, src_dir_fd=None, dst_dir_fd=None, follow_symlinks=True)`
    \- создаёт жёсткую ссылку.

- `os.listdir(path=".")` - список файлов и директорий в папке.

- `os.mkdir(path, mode=0o777, *, dir_fd=None)` - создаёт директорию.
    OSError, если директория существует.

- `os.makedirs(path, mode=0o777, exist_ok=False)` - создаёт директорию,
    создавая при этом промежуточные директории.

- `os.remove(path, *, dir_fd=None)` - удаляет путь к файлу.

- `os.rename(src, dst, *, src_dir_fd=None, dst_dir_fd=None)` -
    переименовывает файл или директорию из src в dst.

- `os.renames(old, new)` - переименовывает old в new, создавая
    промежуточные директории.

- `os.replace(src, dst, *, src_dir_fd=None, dst_dir_fd=None)` -
    переименовывает из src в dst с принудительной заменой.

- `os.rmdir(path, *, dir_fd=None)` - удаляет пустую директорию.

- `os.removedirs(path)` - удаляет директорию, затем пытается удалить
    родительские директории, и удаляет их рекурсивно, пока они пусты.

- `os.symlink(source, link_name, target_is_directory=False, *, dir_fd=None)`
    \- создаёт символическую ссылку на объект.

- `os.sync()` - записывает все данные на диск (Unix).

- `os.truncate(path, length)` - обрезает файл до длины length.

- `os.utime(path, times=None, *, ns=None, dir_fd=None, follow_symlinks=True)`
    \- модификация времени последнего доступа и изменения файла. Либо
    times - кортеж (время доступа в секундах, время изменения в
    секундах), либо ns - кортеж (время доступа в наносекундах, время
    изменения в наносекундах).

- `os.walk(top, topdown=True, onerror=None, followlinks=False)` -
    генерация имён файлов в дереве каталогов, сверху вниз (если topdown
    равен True), либо снизу вверх (если False). Для каждого каталога
    функция walk возвращает кортеж (путь к каталогу, список каталогов,
    список файлов).

- `os.system(command)` - исполняет системную команду, возвращает код её
    завершения (в случае успеха 0).

- `os.urandom(n)` - n случайных байт. Возможно использование этой ф-ции
    в криптографических целях.

- `os.path` - модуль, реализующий некоторые полезные функции на работы с
    путями.
________________________________________________________________________

### pathlib ###

Для работы с путями как объектами.

**Более подробно**: см. Н. Седер или Интернет.
________________________________________________________________________

### pickle ###

Модуль pickle реализует мощный алгоритм сериализации и десериализации
объектов Python. "Pickling" - процесс преобразования объекта Python в
поток байтов, а "unpickling" - обратная операция, в результате которой
поток байтов преобразуется обратно в Python-объект. Так как поток байтов
легко можно записать в файл, модуль pickle широко применяется для
сохранения и загрузки сложных объектов в Python.
________________________________________________________________________

Ф-ции:

- `pickle.dump(obj, file, protocol=None, *, fix_imports=True)` -
    записывает сериализованный объект в файл. Дополнительный аргумент
    protocol указывает используемый протокол. По умолчанию равен 3 и
    именно он рекомендован для использования в Python 3 (несмотря на то,
    что в Python 3.4 добавили протокол версии 4 с некоторыми
    оптимизациями). В любом случае, записывать и загружать надо с одним
    и тем же протоколом.

- `pickle.dumps(obj, protocol=None, *, fix_imports=True)` - возвращает
    сериализованный объект. Впоследствии вы его можете использовать как
    угодно.

- `pickle.load(file, *, fix_imports=True, encoding="ASCII", errors="strict")`
    \- загружает объект из файла.

- `pickle.loads(bytes_object, *, fix_imports=True, encoding="ASCII", errors="strict")`
    \- загружает объект из потока байт.

Исключения:

- `pickle.PickleError`
    - `pickle.PicklingError` - случились проблемы с сериализацией
        объекта.
    - `pickle.UnpicklingError` - случились проблемы с десериализацией
        объекта.

Пример:

```python
import pickle
data = {
        'a': [1, 2.0, 3, 4+6j],
        'b': ("character string", b"byte string"),
        'c': {None, True, False}
        }

with open('data.pickle', 'wb') as f:
    pickle.dump(data, f)

with open('data.pickle', 'rb') as f:
    data_new = pickle.load(f)

print(data_new)

# Результат:
# {'c': {False, True, None}, 'a': [1, 2.0, 3, (4+6j)],
# 'b': ('character string', b'byte string')}
```
________________________________________________________________________

### queue ###

Для реализации очереди, стека и приоритетной очереди.

Классы:

- `Queue(maxsize=0)` - очередь, FIFO. maxsize > 0 => ограниченная, при
    переполнении вызывает ошибку. В ином случае очередь считается
    бесконечно расширяемой.

- `LifoQueue(maxsize=0)` - стек, LIFO.

- `PriorityQueue(maxsize=0)` - приоритетная очередь.

- `SimpleQueue()` - простая очередь FIFO без дополнительных фич, как,
    например, трекинг задач или максимальный размер.

- `Empty`, `Full`, `ShutDown` - исключения.

Методы очередей:

- `Queue.qsize()` - размер.

- `Queue.empty()`, `Queue.full()` - проверка, пустая ли или полная ли
    соответственно. Проверка на полноту не работает для SimpleQueue.

- `Queue.put(item, block=True, timeout=None)` - добавить в очередь.
    block и timeout отвечает за блокировку очереди в случае
    заполненности после данного добавления. `block=True` - включить
    блокировку при отсутсвии свободного места. `timeout=n` - блокировка
    на n секунд, и если за это время не освобождается место - выдает
    исключение.

- `Queue.put_nowait(item)` - `put` с `block=False`.

- `Queue.get(block=True, timeout=None)` - удалить эл-т из очереди и
    вернуть удаленный эл-т. block и timeout отвечают за блокировку в
    случае опустошения очереди после данного удаления по аналогии с put.

- `Queue.get_nowait()` - `get` с `block=False`.

- Имеются ф-ции для отслеживания выполнения задач, исп-ся для выполнения
    в отдельном потоке. Не работает для SimpleQueue.

- `Queue.shutdown(immediate=False)` - "выключить" очередь, отключая
    возм-ть добавлять новые эл-ты. Удалять старые по умолчанию можно, но
    при `immediate=True` - нельзя. Не работает для SimpleQueue.
________________________________________________________________________

### re ###

Модуль для работы с регулярными выражениями (RegEx, "регулярки").

В общем и целом регулярные выражения - сильный инструмент для поиска по
строке или тексту по шаблону. Но также это не самый быстрый и понятный
для последующего прочтения инструмент (так называемый write-only code).
Важно понимать, действительно ли это регулярное выражение необходимо или
можно обойтись более читабельными или быстрыми инструментами.

Синтаксис регулярных выражений выписывать не буду, по необх-ти - см.
Интернет или источник в конце описания модуля re.
________________________________________________________________________

Ф-ции:

- `re.search(pattern, string)` - найти в строке string первую строчку,
    подходящую под шаблон pattern.

- `re.fullmatch(pattern, string)` - проверить, подходит ли строка string
    под шаблон pattern.

- `re.split(pattern, string, maxsplit=0)` - аналог `str.split()`, только
    разделение происходит по подстрокам, подходящим под шаблон pattern.

- `re.findall(pattern, string)` - найти в строке string все
    непересекающиеся шаблоны pattern.

- `re.finditer(pattern, string)` - итератор по всем непересекающимся
    шаблонам pattern в строке string (выдаются match-объекты).

- `re.sub(pattern, repl, string, count=0)` - заменить в строке string
    все непересекающиеся шаблоны pattern на repl.

Константы:

- `re.ASCII` - по умолчанию \w, \W, \b, \B, \d, \D, \s, \S соответствуют
    все юникодные символы с соответствующим качеством. re.ASCII ускоряет
    работу, если все соответствия лежат внутри ASCII.

- `re.IGNORECASE` - не различать заглавные и маленькие буквы. Работает
    медленнее, но иногда удобно.

- `re.MULTILINE` - специальные символы ^ и $ соответствуют началу и
    концу каждой строки.

- `re.DOTALL` - по умолчанию символ \n конца строки не подходит под
    точку. С этим флагом точка — вообще любой символ.

Немного про match-объекты:

- `match[0]`, `match.group()` - подстрока, соответствующая шаблону.

- `match.start()` - индекс в исходной строке, начиная с которого идёт
    найденная подстрока.

- `match.end()` - индекс в исходной строке, который следует сразу за
    найденной подстрокой.
________________________________________________________________________

**Документация**:
[ссылка](https://docs.python.org/3/library/re.html).

**Про регулярные выражения и Python**:
[ссылка](https://habr.com/ru/articles/349860/).
________________________________________________________________________

### shelve ###

Реализует постоянное хранилище для произвольных объектов Python,
значения которого можно извлекать, используя словарные методы, что
облегчает переход от сценариев на основе словаря к тем, которые требуют
постоянного хранения. В качестве ключей хранилища shelve используются
обычные строки.

Под понятием произвольных объектов Python понимается все, что может
обрабатывать модуль `pickle`. Это включает в себя большинство
экземпляров классов, рекурсивных типов данных и объектов, содержащих
множество общих подобъектов.

Ограничения:

- Выбор того, какой пакет базы данных будет использоваться, например
    dbm.ndbm или dbm.gnu, зависит от того, какой интерфейс доступен в
    системе. Поэтому небезопасно открывать базу данных напрямую с
    помощью dbm.
- База данных, к сожалению, также подвержена ограничениям dbm. Это
    означает, что сохраненные объекты по средствам `pickle.dumps`,
    должны быть довольно маленькими, а в редких случаях совпадения
    ключей могут привести к тому, что база данных будет отказываться от
    обновлений.
- Модуль shelve не поддерживает одновременный доступ для чтения/записи к
    отложенным объектам. Несколько одновременных обращений к чтению
    постоянного хранилища shelve безопасны. Но если хранилище открыто
    для записи, никакая другая программа не должна открывать ее для
    чтения или записи. Для решения этой проблемы можно использовать
    блокировку файлов Unix, но она отличается в разных версиях Unix и
    требует знания используемой реализации базы данных.

Примеры использования:

```python
import shelve

# файл может получить суффикс, добавленный низкоуровневой библиотекой
db = shelve.open(filename)

# Сохранить данные с ключом 'key', перезапишет старые данные, если ключ
# существует.
db[key] = data

# Получить КОПИЮ данных по ключу, вызывает KeyError, если такого ключа
# нет.
data = db[key]

# Удалить данные, хранящиеся по ключу вызывает KeyError, если такого
# ключа нет.
del db[key]

# True, если ключ существует
flag = key in db

# Список всех существующих ключей - медленно!
klist = list(db.keys())

# Если хранилище открыто без аргумента 'writeback=True'
db['xx'] = [0, 1, 2]   # Работает как положено, но ...
db['xx'].append(3)     # !Это не так!, d['xx'] все еще [0, 1, 2]!

# Открыв хранилище без аргумента 'writeback=True', делайте следующим
# образом
temp = db['xx']       # Извлекает копию
temp.append(5)       # Обновляет копию
db['xx'] = temp       # Сохраняет копию в хранилище

# закрывает хранилище 
db.close()

# или можно открыть хранилище с 'writeback=True'
with shelve.open(filename, writeback=True) as db:
    # То метод .append будет работать как положено, НО тогда процесс
    # будет занимать больше памяти и замедлять закрытие хранилища
    db['xx'].append(5)
```
________________________________________________________________________

### shutil ###

Модуль shutil содержит набор функций высокого уровня для обработки
файлов, групп файлов, и папок. В частности, доступные здесь функции
позволяют копировать, перемещать и удалять файлы и папки. Часто
используется вместе с модулем os.

**Подробнее**:
[ссылка](https://pythonworld.ru/moduli/modul-shutil.html).
________________________________________________________________________

### socket ###

Для работы с сокетами - фундаментальным механизмом сетевого
взаимодействия. По сути представляет комбинацию IP-адреса и порта.

Основные ф-ции:

- `socket.socket()` - создает новый сокет. Есть два параметра: тип
    адреса (для IPv4 - `socket.AF_INET`) и протокол связи (для TCP -
    `socket.SOCK_STREAM`, для UDP - `socket.SOCK_DGRAM`). Может выдать
    `socket.error` - исключение, которое можно обработать.

- `socket.bind((host, port))` - связывает сокет с определенным адресом и
    портом. host: str - адрес ('localhost' или '127.0.0.1' для
    локального хоста), post: int - порт.

- `socket.listen(backlog)` - начинает прослушивание входящих соединений.
    Параемтр для определения максимального кол-ва ожидающих соединений.

- `socket.accept()` - принять входящее соединение. Возвращает сокет и
    адрес с портом клиента.

- `socket.connect((host, port))` - устанавливает соединение с удаленным
    сервером.

- `socket.send(data)` - отправляет данные по сокету. Может отправить
    только часть данных, поэтому лучше использовать `sendall`. Работает
    с data в виде байтов, поэтому перед отправкой использовать метод
    `encode` или что-то в этом духе.

- `socket.recv(buffersize)` - получает данные из сокета. Параметр -
    макс. число байт. Получаемые данные в виде байтов, так что надо
    декодировать с помощью метода `decode` или чего-то в этом духе.

- `socket.close()` - закрывает сокет.

Возможные исключения:

- `socket.error` - общая ошибка сокета.

- `ConnectionRefusedError` - сервер отказался принять соединение. Это
    может произойти, если сервер не запущен или не прослушивает
    указанный порт.

- `TimeoutError` - таймаут соединения. Это может произойти, если
    соединение не было установлено в течение определенного времени.

- `BlockingIOError` - сокет находится в неблокирующем режиме и операция
    не может быть выполнена немедленно. (Чаще встречается при работе с
    неблокирующими сокетами, что является более продвинутой темой.)
________________________________________________________________________

Пример: эхо-сервер TCP:

```python
import socket

HOST = 'localhost'
PORT = 12345

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.bind((HOST, PORT))
    s.listen()
    conn, addr = s.accept()
    with conn:
        print('Соединение установлено с:', addr)
        while True:
            data = conn.recv(1024)
            if not data:
                break
            conn.sendall(data)
```

И клиент для эхо-сервера:

```python
import socket

HOST = 'localhost'
PORT = 12345

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect((HOST, PORT))
    message = "Привет, эхо-сервер!"
    s.sendall(message.encode('utf-8'))
    data = s.recv(1024)
    print('Получено от сервера:', data.decode('utf-8'))
```
________________________________________________________________________

Пример: эхо-сервер UDP:

```python
import socket

HOST = 'localhost'
PORT = 12345
BUFFER_SIZE = 1024

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.bind((HOST, PORT))

print(f"UDP сервер запущен на {HOST}:{PORT}")

while True:
    data, address = s.recvfrom(BUFFER_SIZE)
    message = "Эхо: " + data.decode('utf-8')
    s.sendto(message.encode('utf-8'), address)
    print(f"Отправлено эхо-сообщение '{message}' клиенту {address}")
```

И клиент для эхо-сервера:

```python
import socket

HOST = 'localhost'
PORT = 12345
MESSAGE = "Привет, UDP сервер!"
BUFFER_SIZE = 1024

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.sendto(MESSAGE.encode('utf-8'), (HOST, PORT))
data, address = s.recvfrom(BUFFER_SIZE) # Ждем ответа от сервера
print(f"Получено сообщение '{data.decode('utf-8')}' от {address}")
s.close()
```
________________________________________________________________________

**Документация**:
[ссылка](https://docs.python.org/3/library/socket.html).

**Гайдик**:
[ссылка](https://pyhub.ru/python-advanced/lecture-11-73-1034/).
________________________________________________________________________

### sqlite3 ###

Для работы с SQLite.

**Подробнее**: см. Н. Седер, Интернет или SQLite.txt.
________________________________________________________________________

### string ###

Модуль string в Python предоставляет константы и классы для работы со
строками, облегчая проверку и форматирование.

Константы - разные наборы тех или иных групп символов (ASCII - все,
заглавные, строчные; цифры - в десятичной, восьмиричной или
шестнадцатиричной системе; знаки пунктуации; пробельные символы;
печатные символы - обобщение всех вышеописанных).

Кроме того, содержит классы Formatter и Template для форматирования
строк и сборку по шаблонам.

**Документация**:
[ссылка](https://docs.python.org/3/library/string.html).

**Еще источник**:
[ссылка](https://docs-python.ru/standart-library/modul-string-python/).
________________________________________________________________________

### struct ###

Модуль выполняет преобразования между Python значениями и C структурами,
представленными как bytes объекты Python. Может использоваться для
обработки двоичных данных, хранящихся в файлах или из сетевых
подключений, а также из других источников. Кроме того, может, наоборот,
упаковать данные для дальнейшего хранения или передачи.

**Документация**:
[ссылка](https://docs.python.org/3/library/struct.html).

**Подробнее**:
[ссылка](https://digitology.tech/docs/python_3/library/struct.html).
________________________________________________________________________

### sys ###

Модуль sys обеспечивает доступ к некоторым переменным и функциям,
взаимодействующим с интерпретатором Python.

Ф-ции и константы:

- `sys.argv` - список аргументов командной строки, передаваемых сценарию
    Python. `sys.argv[0]` является именем скрипта (пустой строкой в
    интерактивной оболочке).

- `sys.byteorder` - порядок байтов. Будет иметь значение 'big' при
    порядке следования битов от старшего к младшему, и 'little', если
    наоборот (младший байт первый).

- `sys.builtin_module_names` - кортеж строк, содержащий имена всех
    доступных модулей.

- `sys.call_tracing(функция, аргументы)` - вызывает функцию с
    аргументами и включенной трассировкой, в то время как трассировка
    включена.

- `sys._clear_type_cache()` - очищает внутренний кэш типа.

- `sys._current_frames()` - возвращает словарь-отображение
    идентификатора для каждого потока в верхнем кадре стека в настоящее
    время в этом потоке в момент вызова функции.

- `sys.exc_info()` - возвращает кортеж из трех значений, которые дают
    информацию об исключениях, обрабатывающихся в данный момент.

- `sys.exec_prefix` - каталог установки Python.

- `sys.executable` - путь к интерпретатору Python.

- `sys.exit([arg])` - выход из Python. Возбуждает исключение SystemExit,
    которое может быть перехвачено.

- `sys.flags` - флаги командной строки. Атрибуты только для чтения.

- `sys.float_info` - информация о типе данных float.

- `sys.float_repr_style` - информация о применении встроенной функции
    repr() для типа float.

- `sys.getdefaultencoding()` - возвращает используемую кодировку.

- `sys.getfilesystemencoding()` - возвращает кодировку файловой системы.

- `sys.getrefcount(object)` - возвращает количество ссылок на объект.
    Аргумент функции getrefcount - еще одна ссылка на объект.

- `sys.getrecursionlimit()` - возвращает лимит рекурсии.

- `sys.getsizeof(object[, default])` - возвращает размер объекта
    (в байтах).

- `sys.getswitchinterval()` - интервал переключения потоков.

- `sys.getwindowsversion()` - возвращает кортеж, описывающий версию
    Windows.

- `sys.hash_info` - информация о параметрах хэширования.

- `sys.implementation` - объект, содержащий информацию о запущенном
    интерпретаторе Python.

- `sys.int_info` - информация о типе int.

- `sys.intern(строка)` - возвращает интернированную строку.

- `sys.last_type`, `sys.last_value`, `sys.last_traceback` - информация
    об обрабатываемых исключениях. По смыслу похоже на `sys.exc_info()`.

- `sys.maxsize` - максимальное значение числа типа Py_ssize_t (231 на
    32-битных и 263 на 64-битных платформах).

- `sys.maxunicode` - максимальное число бит для хранения символа
    Unicode.

- `sys.modules` - словарь имен загруженных модулей. Изменяемый.

- `sys.path` - список путей поиска модулей.

- `sys.path_importer_cache` - словарь-кэш для поиска объектов.

- `sys.platform` - информация об операционной системе.
    - Linux (2.x and 3.x) - 'linux'
    - Windows - 'win32'
    - Windows/Cygwin - 'cygwin'
    - Mac OS X - 'darwin'
    - OS/2 - 'os2'
    - OS/2 EMX - 'os2emx'

- `sys.prefix` - папка установки интерпретатора Python.

- `sys.ps1`, `sys.ps2` - первичное и вторичное приглашение
    интерпретатора (определены только если интерпретатор находится в
    интерактивном режиме). По умолчанию `sys.ps1 == ">>> "`, а
    `sys.ps2 == "... "`.

- `sys.dont_write_bytecode` - если True, Python не будет писать
    .pyc файлы.

- `sys.setrecursionlimit(предел)` - установить максимальную глубину
    рекурсии.

- `sys.setswitchinterval(интервал)` - установить интервал переключения
    потоков.

- `sys.settrace(tracefunc)` - установить "след" функции.

- `sys.stdin`, `sys.stdout`, `sys.stderr` - стандартный ввод, вывод и
    поток ошибок соответственно.

- `sys.__stdin__`, `sys.__stdout__`, `sys.__stderr__` - исходные
    значения потоков ввода, вывода и ошибок.

- `sys.tracebacklimit` - максимальное число уровней отслеживания.

- `sys.version` - версия Python.

- `sys.api_version` - версия C API.

- `sys.version_info` - кортеж, содержащий пять компонентов номера
    версии.

- `sys.warnoptions` - реализация предупреждений.
________________________________________________________________________

**Документация**:
[ссылка](https://docs.python.org/3/library/sys.html).

**Статья по sys**:
[ссылка](https://pythonworld.ru/moduli/modul-sys.html).
________________________________________________________________________

### threading ###

Модуль для многопоточности в Python. Не забываем про GIL и то, что
потоки вследствие наличия онного выполняются конкурентно, а не
параллельно. Поэтому не подходит для CPU-bound (интенсивные вычисления)
задач, но подходит прекрасно I/O-bound (инпут-аутпут, ожидание
считывания, записи, вывода и т.п.).

По необх-ти - подробнее почитать.

**Документация**:
[ссылка](https://docs.python.org/3/library/threading.html).

**Про многопоточность на Python Academy**:
[ссылка](https://python-academy.org/ru/guide/threading-module).
________________________________________________________________________

### time ###

Модуль для работы со временем и датами. В оригинале считает время в
секундах от начала эпохи.

`time.sleep(seconds)` - для остановки процесса на seconds секунд.

В остальном см. источник ниже.

**Подробнее**:
[ссылка](https://pythonworld.ru/moduli/modul-time.html).
________________________________________________________________________

### timeit ###

Модуль для проверки, сколько занимает выполнение какой-либо ф-ции или
куска кода.

`timeit.timeit(stmt='pass', setup='pass', timer=<default timer>, number=1000000, globals=None)`
\- основная ф-ция, где stmt - код для выполнения в виде
строки для eval или ф-ции, setup - в том же ключе выполняемые
приготовления, number - число повторений для оценки времени.

В остальном - см. документацию.

**Документация**:
[ссылка](https://docs.python.org/3/library/timeit.html).
________________________________________________________________________

### typing ###

Модуль для аннотации типов данных. Нужен для читаемости кода, а также
для удобства в IDE или для линтеров кода.
________________________________________________________________________

Сначала дополним классическую инфиксную аннотацию аргументов и
возвращаемого результата ф-ций еще некоторыми фичами:

```python
# аннотация дозволена для любой переменной без присваивания значения
some_var: int

# или с присваиванием
some_var2: int = 5

# можно задавать элиасы для типов данных
Vector = list[int, int]       # до версии 3.12, но можно и с нее
type Vector = list[int, int]  # с версии 3.12
Vector: typing.TypeAlias = list[int, int]  # с typing

# аннотация для словарей
some_dict: dict[str, int] = {'str': 1}

# аннотации для мн-в, списков и кортежей
smth: list[int, int] = [1, 2]
smth1: list[int] = [1, 2, 3, ...]
smth2: list[int | float] = [1, 2.0, 3.0, 4, ...]

# для неопределенного размера списков или для ф-ций неопределенной
# конфигурации используется ...
list1: list[int, float, ...] = [1, 2.0, 3, 4.0, ...]
f1: Callable[[...], int]
```
________________________________________________________________________

Теперь перейдем к непосредственно typing.

- `Callable[[arg1, arg2, ...], return]` - аннотация для ф-ций.

- `def some_generator() -> Iterator[type]` - аннотация для возвращаемого
    значения ф-ций-генераторов.

- Можно задавать аннотации и для `*args`, `**kwargs` в аргументах ф-ций.

- `ClassVar[type]` - для аннотации переменной класса (не экземпляра).

- `Any` - для любого значения.

- `Iterable[type]` - итерируемый.

- `Sequence[type]` - частный случай Iterable, пос-ть, поддерживающая len
    и обращение по индексу.

- `Mapping[ktype, vtype]`, `MutableMapping[ktype, vtype]` -
    словареподобный, мэппинг. Не предполагается изменять и
    предполагается соответственно.

- `IO[type]` - для сериализованного вывода с какого-либо инпута или
    аутпута (в т.ч. стандартных потоков).

- `from __future__ import annotations` - для аннотирования типов,
    которые объявлены после строки с аннотацией. Например, если ф-ция
    объявлена раньше типа или класса, или, что более частый пример,
    при наличии в методе класса аргумента, принимающего экземпляр этого
    же класса.

- `def bare_decorator[F: Callable[..., Any]](func: F) -> F:` - пример
    аннотации декоратора в 3.12. В более ранних версиях F пришлось
    задать как элиас заранее.
________________________________________________________________________

**Документация**:
[ссылка](https://docs.python.org/3/library/typing.html).

**Шпаргалка mypy**:
[ссылка](https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html).
________________________________________________________________________

### venv ###

Для создания виртуального окружения.

- `python -m venv my_project_environment` - для создания виртуального
    окружения my_project_environment, или, точнее, создания в текущей
    папке пакпки с данными виртуального окружения. Имя для виртуального
    окружения можно не давать, по умолчанию - venv.

- Для запуска надо выполнить activate.bat в папке виртуального
    окружения. Для отключения - прописать команду `deactivate`.

- Внутри виртуального окружения можно устанавливать библиотеки по тем же
    законам, что и в обычном случае.

В остальном - см. Интернет.
________________________________________________________________________

### zlib ###

Для сжатия данных. Подробнее см. документацию.

**Документация**:
[ссылка](https://docs.python.org/3/library/zlib.html).
________________________________________________________________________

# ВНЕШНИЕ #

### flake8 ###

Для проверки проекта по PEP 8. Имеет ряд дополнительных модулей для
проверки по отдельным родам ошибок.

**Более подробно**:
[ссылка](https://habr.com/ru/companies/dataart/articles/318776/).
________________________________________________________________________

### matplotlib ###

...
________________________________________________________________________

### numba ###

Библиотека для JIT-компиляции кода в Python.

**Статьи на Хабре**:
- [ссылка](https://habr.com/ru/companies/ruvds/articles/708358/).
- [ссылка](https://habr.com/ru/articles/484142/).
________________________________________________________________________

### numpy ###

...
numpy.inf, -numpy.inf
________________________________________________________________________

### pandas ###

...
________________________________________________________________________

### psycopg2 ###

Для связи с БД PostgreSQL.

**Более подробно**: см. конспект PostgreSQL.
________________________________________________________________________

### pymodbus ###

Для установления Modbus-соединений.

**Документация**:
[ссылка](https://pymodbus.readthedocs.io/en/latest/).
________________________________________________________________________

### pygame ###

Для создания игр. В более широком смысле может использоваться для ГПИ.

**Более подробно**: см. Интернет.
________________________________________________________________________

### PyQt ###

...
________________________________________________________________________

### PySide ###

...
________________________________________________________________________

### requests ###

Для работы с HTTP-запросами.

**Документация**:
[ссылка](https://requests.readthedocs.io/en/latest/index.html).

**Гайдик от Яндекс Образования**:
[ссылка](https://education.yandex.ru/handbook/python/article/modul-requests).
________________________________________________________________________

### scipy ###

...
________________________________________________________________________

### sqlalchemy ###

Библиотека для работы с реляционными БД, представляющая функционал ORM.
Стоит лишний раз отметить, что ORM следует использовать для работы с
небольшими наборами данных, т.к. он добавляет сложности, а в случае
больших данных использовать чистый SQL.

**Гайд на пример SQLite**:
[ссылка](https://metanit.com/python/database/3.3.php).
________________________________________________________________________

# МАТЕРИАЛЫ #

1. [Литература] **Наоми Седер - Python. Экспресс-курс**.
1. [Сайт] **Источники и доп. материалы, если таковые имеются,**
    **информации по библиотекам указаны в их разделах.**
________________________________________________________________________
